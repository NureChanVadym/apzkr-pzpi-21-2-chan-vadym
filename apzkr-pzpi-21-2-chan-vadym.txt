Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА

з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для розумного розподілення комунальними ресурсами

Студент гр. ПЗПІ-21-2	________ _______ Чан В.Х.
(підпис)
Керівник роботи	____________ доц. Лещинський В.О.
(підпис)
Роботу захищено «__»червня 2024 р.
  з оцінкою ______________________

Комісія:	_____________ доц. Лещинський В.О.
(підпис)
_____________ доц. Лещинська І.О.
(підпис)
_____________ ст.викл. Сокорчук І.П.
(підпис)
Харків
2024 р.
Харківський національний університет радіоелектроніки 
Факультет комп’ютерних наук       Кафедра програмної інженерії                 .
Спеціальність 121 – Інженерія програмного забезпечення                               .
Курс       3          Група          ПЗПІ-21-2             Семестр                    6       .
Навчальна дисципліна  Аналіз вимог до програмного забезпечення

ЗАВДАННЯ 
НА ЛАБОРАТОРНІ РОБОТИ СТУДЕНТОВІ 

                                                      Чану Вадиму Ха                                             .
1. Тема проєкту: Програмна система для розумного розподілення ресурсами
2. Термін узгодження завдання з лабораторних робіт «26» лютого  2024 р.
3. Термін здачі завдання з лабораторних робіт «15» червня  2024 р.
 4. Вихідні дані до проєкту: В програмній системі передбачити: управління обліковими даними користувачами, перегляд споживання, управління IoT пристроями. Використовувати ОС Windows 11, СКБД PostgreSQL, інтегроване середовище розробки Microsoft Visual Studio, WebStorm                                                          .
5. Зміст пояснювальної записки (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки.                                                                  6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень): UML діаграма розгортання (Deployment Diagram), UML діаграма прецедентів (Use Case Diagram), ER-модель даних (Entity–Relationship Model), UML діаграма взаємодії (Interaction Overview Diagram), UML діаграма діяльності (Activity Diagram), UML діаграма компонент (Component Diagram).
 
КАЛЕНДАРНИЙ ПЛАН 


№	Основні етапи виконання проєкту
в рамках лабораторних робіт	Термін виконання
етапів	Примітка
1	 Документ Vision & Scope	22.03.2024	виконано
2	 Серверна частина системи	12.04.2024	виконано
3	 Програмне забезпечення для IoT пристрою	26.04.2024	виконано
4	 Клієнтська частина системи	17.05.2024	виконано
5	 Мобільний застосунок	31.05.2024	виконано

Дата видачі завдання « 26 »лютого 2024 р.
Керівник                                                                              доц. Лещинський В. О.
 		(підпис)

Завдання прийняла до виконання
ст. гр. ПЗПІ-21-2                                                                 Чан В.Х.
         (підпис)




 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 141 с., 22 рис., 3 табл., 3 додатки, 3 джерела.
АДМІНІСТРАТОР, АРХІТЕКТУРА ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ, ВОДА, ГАЗ, ЕЛЕКТРОЕНЕРГІЯ, КОМУНАЛЬНІ РЕСУРСИ, КОРИСТУВАЧ, ПАТЕРНИ ПРОЕКТУВАННЯ, СПОЖИВАННЯ.
Метою роботи є розробка програмної системи для розумного розподілення комунальними ресурсами.
Методи розробки базуються на застосуванні інтегрованих середовищ розробки Visual Studio, WebStorm, PostgreSQL, мов програмування C#, C++, JavaScript, фреймворків MAUI, ASP.NET CORE, бібліотеки React.js, мікроконтролера ESP32.
У результаті отримано програмну систему із назвою «EcoMeChan», яка дає користувачам змогу через веб-інтерфейс та мобільний застосунок здійснювати моніторинг та управління використання водних, енергетичних, та газових ресурсів. Веб-інтерфейс у ролі адміністратора дозволяє переглядати інформацію щодо споживання ресурсів, редагувати та управляти даними про ресурси, а також налаштовувати автоматичне управління постачанням відповідно до змін у споживанні. 
Мобільний застосунок дозволяє користувачам у реальному часі відстежувати використання ресурсів. Додатково, система надає можливість інтеграції з IoT-датчиками для точного збору даних щодо споживання води, газу та електроенергії. Зібрані дані автоматично передаються на сервер, де вони зберігаються в базі даних для подальшого аналізу.
Така програмна система дозволяє автоматизувати процеси моніторингу та управління ресурсами, сприяючи більш ефективному використанню природних ресурсів, зменшенню витрат та підвищенню екологічної відповідальності. Завдяки EcoMeChan організації та домогосподарства отримують інструменти для прозорого та відповідального управління своїм споживанням, що сприяє раціональному розподілу ресурсів та зменшенню їхнього негативного впливу на довкілля. 
ЗМІСТ


ЗМІСТ	6
ВСТУП	8
1.	СПЕЦИФІКАЦІЯ СИСТЕМИ	9
1.1	Бізнес-вимоги	9
1.2	Концепція рішення	14
1.3	Рамки та обмеження	18
1.4	Бізнес-контекст	21
2	СЕРВЕРНА ЧАСТИНА	26
2.1	Моделювання програмної системи	26
2.2	Структура та взаємозв’язки у базі даних	27
2.3	Розробка архітектури проекту	29
2.4	Програмна розробка системи	30
2.5	Створення резервних копій бази даних	34
3	РОЗУМНИЙ ПРИСТРІЙ (ПРИСТРІЙ IOT)	35
3.1	Моделювання програмної системи	36
3.2	Взаємодія між частинами системи	37
3.3	Архітектура програмної системи	39
3.4	Програмна розробка системи	40
4	КЛІЄНТСЬКА ЧАСТИНА (ФРОНТЕНД ЧАСТИНА)	42
4.1	Моделювання програмної системи	42
4.2	Взаємодія між частинами системи	43
4.3	Архітектура програмної системи	44
4.4	Програмна розробка системи	46
5	МОБІЛЬНИЙ ЗАСТОСУНОК	49
5.1	Моделювання програмної системи	49
5.2	Взаємодія між частинами системи	50
5.3	Архітектура програмної системи	50
5.4	Програмна розробка системи	52
Висновки	54
Перелік посилань	57
Додаток А Схеми та діаграми	58
Додаток Б Приклади коду	70
Додаток В Перевірка на плагіат	142

 
ВСТУП


Результати роботи мають значний потенціал для впровадження в управління ресурсами, критично важливого для суспільства. Система EcoMeChan оптимізує розподіл водних, електричних і газових ресурсів, знижуючи витрати і підвищуючи ефективність. Це дозволить комунальним підприємствам, міським адміністраціям і приватним користувачам ефективніше управляти ресурсами, зменшуючи їх негативний вплив на довкілля та сприяючи сталому розвитку.
Актуальність роботи зумовлена зростанням населення і промислової активності, що створює потребу в інтелектуальних системах управління ресурсами. Сучасні виклики енергетичної ефективності вимагають інноваційних рішень для ефективного розподілу ресурсів. EcoMeChan пропонує комплексний підхід до моніторингу, аналізу та автоматизованого управління ресурсами, що дозволяє економити ресурси, знижувати витрати та підвищувати надійність постачання.
Мета проекту - розробка і впровадження системи розумного розподілу ресурсів з інтегрованим підходом до моніторингу, контролю та оптимізації споживання на міському та регіональному рівнях. Система дозволяє оптимізувати використання ресурсів, зменшувати витрати і покращувати реагування на зміни попиту і постачання. EcoMeChan інтегрує дані для точного аналізу і управління в реальному часі, виявляючи тенденції споживання і прогнозуючи майбутні потреби.
Впровадження системи EcoMeChan сприятиме підвищенню ефективності управління ресурсами, сталому розвитку, зниженню екологічного впливу і покращенню якості життя громадян. Система надає інноваційне, економічно ефективне рішення, забезпечуючи надійність і автоматизацію процесів. 
ОСНОВНА ЧАСТИНА
1.	СПЕЦИФІКАЦІЯ СИСТЕМИ
1.1	Бізнес-вимоги


В цьому підрозділі буде описано передумови створення проекту, бізнес можливості, а саме порівняння з аналогами, принципи монетизації, бізнес-цілі та критерії успіху, потреби клієнтів та ринку, ризики, які можуть перешкоджати створенню або роботі програмної системи. 


1.1.1 	 Передумови


У сучасному світі, де ми стикаємося з неперервним зростанням населення та збільшенням промислової активності, наростає гостра потреба у створенні інтелектуальних систем для управління ключовими ресурсами, як-от вода, електроенергія та газ. Ця потреба не лише відображає виклики, з якими ми стикаємося сьогодні, але й створює сприятливі умови для впровадження інноваційних програмних рішень. Такі системи мають потенціал забезпечити не тільки ефективне розподілення та використання наших обмежених ресурсів, але й мінімізувати втрати, сприяючи тим самим зменшенню їх негативного впливу на довкілля.
Перехід до впровадження програмної системи для розумного розподілення ресурсів стає важливим елементом у контексті енергетичної ефективності та раціональної економії. Основна концепція полягає в наданні можливості для більш ефективного та відповідального використання ресурсів. Це досягається через розробку механізмів моніторингу та управління, які мають бути ефективні у забезпеченні необхідного контролю над споживанням.
В цьому контексті існує потенціал для створення рішення, яке може автоматизувати процеси моніторингу та управління водними, енергетичними та газовими ресурсами, роблячи їх більш прозорими та доступними для споживачів різних категорій. Така система допоможе не тільки комунальним підприємствам в ефективному управлінні ресурсами, але й стане корисною для приватних підприємців та бізнесів, які прагнуть оптимізувати своє споживання та знизити витрати. Крім того, вона надасть необхідні інструменти державним та місцевим органам управління для кращого реагування на поточні та майбутні виклики у сфері ресурсозбереження. Такий підхід дозволить створити більш стабільну та надійну основу для управління різними ресурсами, сприятиме сталому розвитку і підвищить якість життя громадян, роблячи ефективне управління ресурсами центральним елементом сучасного екологічного та економічного планування.


1.1.2 Бізнес-можливості


У сфері управління ресурсами вже існують різноманітні рішення, але більшість з них зосереджені на моніторингу та аналізі споживання, а не на оптимізації розподілу ресурсів. EcoMeChan відрізняється своїм комплексним підходом, який поєднує збір даних, аналіз та автоматизоване управління для досягнення максимальної ефективності використання ресурсів.
Розглянемо деякі існуючі аналоги та конкурентів нашої програмної системи. Наприклад, платформа «Schneider Electric Resource Advisor» надає можливості для відстеження, аналізу та звітування про споживання енергії та води. Однак, на відміну від EcoMeChan, вона не має функцій автоматичного розподілу ресурсів на основі прогнозованого попиту та пріоритетів.
Інший конкурент, «Siemens Energy Management Suite», пропонує інструменти для моніторингу та оптимізації енергоспоживання в будівлях. Проте, EcoMeChan має ширший спектр застосування, охоплюючи не лише енергію, а й інші ресурси, такі як вода та газ. 
Існують також спеціалізовані системи, наприклад, «WaterSmart» для управління водними ресурсами. Однак, ця система зосереджена лише на одному водному типі ресурсу і не забезпечують комплексного підходу до оптимізації розподілу ресурсів, як це робить EcoMeChan.
Основна перевага EcoMeChan полягає в його здатності інтегрувати дані з різних джерел, аналізувати їх та автоматично приймати рішення щодо розподілу ресурсів на основі попиту, пріоритетів та ефективності. Це дозволяє не лише економити ресурси, але й зменшувати витрати та підвищувати надійність постачання.
Щодо моделі монетизації, EcoMeChan може генерувати дохід через ліцензування програмного забезпечення для комунальних підприємств, муніципалітетів та великих корпоративних клієнтів. Додатковими джерелами доходу можуть бути послуги з впровадження, навчання користувачів та технічної підтримки. У довгостроковій перспективі, система може запропонувати преміум-функції, такі як розширена аналітика та прогнозування, за додаткову плату.


1.1.3 	Бізнес-цілі та критерії успіху


БЦ 1: Знизити витрати на комунальні послуги для кінцевих користувачів щонайменше на 20% протягом першого року після впровадження системи.
БЦ 2: Підвищити ефективність використання ресурсів на 30% через розумне розподілення та прогнозування попиту.
БЦ 3: Розширити ринкову частку в секторі управління ресурсами до 15% за три роки.
БЦ 4: Розвинути партнерську мережу з місцевими установами та організаціями для сприяння впровадженню та підтримці системи.
КУ 1: Досягнення зниження витрат на комунальні послуги не менше ніж на 20% для 50% користувачів системи впродовж першого року експлуатації.
КУ 2: Встановлення системи управління ресурсами в не менше ніж 500 локаціях до кінця першого року.
КУ 3: Розширення партнерської мережі до 50 організацій, які підтримують і сприяють впровадженню системи.
КУ 4: Отримання позитивних відгуків від 80% користувачів щодо поліпшення ефективності використання ресурсів.


1.1.4 	Потреби клієнтів та ринку


Організації та домогосподарства, що залежать від постійного постачання води, електроенергії та газу, шукають надійне рішення, яке дозволить ефективно керувати ресурсами, знижуючи витрати та мінімізуючи вплив на довкілля. Основні потреби включають автоматизований моніторинг споживання, прогнозування попиту та автоматизоване управління розподілом ресурсів для оптимізації використання і витрат.
В індустрії також існує попит на системи, здатні інтегруватися з існуючою інфраструктурою, такою як смарт-лічильники та IoT пристрої, для забезпечення точного збору даних в реальному часі. Це включає потребу в аналітичних інструментах для обробки великих даних, щоб передбачати тенденції споживання і виявляти можливість для економії.
З точки зору кінцевих користувачів, існує потреба в прозорості щодо їхнього споживання та витрат на ресурси. Користувачі прагнуть зручних рішень для моніторингу своєї активності споживання, можливості отримання персоналізованих рекомендацій для ефективнішого використання ресурсів.
Ринкові потреби також включають необхідність у сумісності з різними платформами та пристроями, забезпечення легкого доступу до системи через мобільні додатки, та високий рівень безпеки для захисту даних користувачів.
З урахуванням цих потреб, ключовими факторами успіху для системи розумного розподілення ресурсів будуть її масштабованість, надійність, здатність до інтеграції, автоматизація процесів та ефективність у використанні ресурсів. Усунення технічних та функціональних обмежень, притаманних існуючим системам, буде критично важливим для забезпечення прийняття системи ринком. EcoMeChan розроблена з урахуванням цих ключових потреб, надаючи інноваційне, економічно ефективне рішення, що відповідає вимогам сучасного управління ресурсами.


1.1.5 	Бізнес-ризики


Розробка системи розумного розподілення ресурсів включає в себе декілька ключових бізнес ризиків. По-перше, ринок управління ресурсами характеризується високою конкуренцією, з багатьма компаніями, що пропонують аналогічні або частково перекриваючі рішення. Це може створити труднощі для проникнення на ринок нашої системи та її визнання серед потенційних клієнтів.
По-друге, існує ризик сприйняття з боку клієнтів, які можуть бути неготовими до змін або вагатися в нових технологічних рішеннях, особливо якщо це стосується критично важливих ресурсів (вода, електроенергія). Така недовіра може знижувати швидкість адаптації системи на ринку.
Також важливим є ризик, пов’язаний з технологічними викликами, включаючи інтеграцію з існуючими системами управління ресурсами, що може виявитися складнішою, ніж очікувалося, або може вимагати значних витрат на налагодження.
Для мінімізації цих ризиків, необхідно проводити глибокий аналіз ринку та потреб користувачів, а також ретельно планувати процес реалізації, включаючи тестування і впровадження системи. Важливо також активно працювати над створенням позитивного іміджу системи, підкреслюючи її надійність, ефективність і безпеку для забезпечення високого рівня довіри та задоволення користувачів.


1.2	Концепція рішення


В цьому підрозділі буде окреслено концепцію програмної системи, а саме мета, завдання програмної системи, головна функціональність, припущення та залежності. 



1.2.1 	 Окреслення концепції


EcoMeChan – це програмна система розумного розподілення комунальними ресурсами, створена для ефективного управління водними, електричними та газовими ресурсами. Ця система забезпечує інтегрований підхід до моніторингу, контролю та оптимізації споживання ресурсів на міському та регіональному рівнях, використовуючи передові технології для забезпечення сталого розвитку та зниження екологічного впливу.
Головна мета EcoMeChan полягає в оптимізації використання природних ресурсів, таких як вода, електроенергія та газ, для забезпечення сталого розвитку та мінімізації екологічного впливу. Система дозволяє міським адміністраціям, комунальним підприємствам та приватним користувачам оптимізувати використання ресурсів, зменшити витрати та покращити реагування на зміни у попиті та постачанні.
EcoMeChan інтегрує дані від різних джерел моніторингу, для забезпечення точного аналізу та управління в реальному часі. Це дозволяє не лише виявляти та аналізувати тенденції споживання, але й прогнозувати майбутні потреби для попередження надлишку або нестачі ресурсів.
При впровадженні EcoMeChan, міста та підприємства отримують можливість не тільки знижувати екологічний вплив, але й значно покращувати свою економічну ефективність, адаптуючи споживання ресурсів до актуальних потреб і використовуючи дані для прийняття обґрунтованих рішень.
EcoMeChan розроблена з особливою увагою до екологічної відповідальності. Дана система має на меті змінити підхід, з яким міста та організації управляють своїми ресурсами. EcoMeChan прагне перетворити існуючі виклики у сфері управління ресурсами на нові можливості. Це сприятиме не лише підвищенню ефективності, але й сталому розвитку.


1.2.2	       Головна функціональність


MF 1: Моніторинг споживання ресурсів, що дозволяє користувачам в реальному часі відстежувати використання води, газу, та електроенергії, сприяючи свідомому управлінню та оптимізації ресурсів.
MF 2: Автоматизоване управління та оптимізація включають корекцію постачання ресурсів відповідно до змін у споживанні, максимізуючи ефективність та мінімізуючи витрати.
MF 3: Адаптивне планування та реагування на аварійні ситуації гарантують, що система може швидко адаптуватися до змінних умов та ефективно реагувати на нештатні ситуації.
MF 4: Безпека та захист даних забезпечують високий рівень захисту інформації, запобігаючи несанкціонованому доступу та забезпечуючи конфіденційність користувацьких даних.
MF 5: Екологічне відстеження впливу дозволяє оцінювати екологічний вплив споживання ресурсів, сприяючи екологічно відповідальному управлінню.
MF 6: Гнучке масштабування підтримує збільшення або зменшення обсягів використання системи без втрати продуктивності або ефективності.
MF 7: Гнучкий доступ через мобільні та веб-інтерфейси забезпечує зручне керування ресурсами та доступ до інформації з будь-якого місця та пристрою.
MF 8: Багатомовний інтерфейс дозволяє користувачам з різних країн та регіонів легко взаємодіяти з системою, забезпечуючи універсальність та доступність.
MF 9: Зручний доступ до системи з мобільних пристроїв, що дозволяє користувачам керувати ресурсами та отримувати інформацію в будь-який час і з будь-якого місця, забезпечуючи максимальну гнучкість та оперативність в управлінні ресурсами.
MF 10: Реєстрація та авторизація користувачів з різними рівнями доступу, що забезпечує індивідуальний та безпечний доступ до функціоналу системи відповідно до ролей та відповідальності.
MF 11: Ведення інтегрованої бази даних ресурсів, що дозволяє зберігати, пошукувати та управляти даними про споживання, ресурси та інфраструктурні елементи, сприяючи покращенню планування та аналізу.
MF 12: Індивідуальний кабінет користувача, де можна переглядати детальну інформацію про споживання ресурсів, історію платежів, та управляти планами оптимізації використання.


2.3	    Припущення та залежності


Припущення:
	припускаємо, що користувачі системи EcoMeChan мають доступ до Інтернету для забезпечення стабільної та ефективної взаємодії з системою;
	вважаємо, що мобільні та стаціонарні пристрої користувачів відповідають технічним вимогам для коректної роботи додатку та інтерфейсу EcoMeChan;
	припускаємо, що користувачі обізнані у використанні сучасних технологій та засобів моніторингу і управління ресурсами через цифрові інтерфейси;
	припускаємо, що користувачі використовують оновлені версії веб-браузерів, що підтримують сучасні веб-технології та стандарти.
Залежності:
	EcoMeChan залежить від стабільного електропостачання для безперервного моніторингу та управління ресурсами, адже основні функції системи, включаючи збір даних з IoT-датчиків і обробку інформації, потребують надійного джерела живлення;
	функціональність системи залежить від наявності та надійності IoT-датчиків і пристроїв зв'язку, що використовуються для моніторингу та управління ресурсами;
	мобільний додаток EcoMeChan може мати конкретні вимоги до операційних систем користувачів, наприклад, Android або iOS останніх версій;
веб-інтерфейс системи може опиратися на певні веб-технології та фреймворки, які оптимізовані для роботи в сучасних веб-браузерах, таких як Chrome, Firefox, Safari, чи Edge.


1.3	Рамки та обмеження


В цьому розділі описано рамки первинного випуску для кожної із частин системи, додаткові відомості про систему, рамки наступних випусків, обмеження.



1.3.1	Рамки первинного випуску


Для мобільного додатку:
	відображення актуальної інформації про споживання ресурсів та доступність води, газу, та електроенергії;
	реєстрація та авторизація користувачів для доступу до персоналізованих даних та управління;
	підтримка української та англійської мов для забезпечення доступності інформації для міжнародних користувачів;
Для Front end:
	можливість реєстрації та авторизації, що надає персоналізований доступ до функцій системи;
	відображення історії споживання ресурсів, що дозволяє користувачам переглядати деталізовану статистику за обраними періодами, сприяючи глибшому аналізу та розумінню тенденцій споживання;
	інтерфейс для адміністраторів та менеджерів з можливістю перегляду, аналізу та редагування даних про ресурси;
	підтримка багатомовного інтерфейсу, включаючи українську та англійську мови;
	управління даними та налаштуваннями системи для забезпечення ефективного управління ресурсами.
Для Back end:
	обробка запитів від мобільних та веб-інтерфейсів;
	безпека даних і їх шифрування;
	реєстрація та авторизація користувачів;
	централізоване зберігання, обробка та аналіз даних про споживання ресурсів;
	забезпечення цілісності та актуальності інформації;
	адміністрування прав доступу для різних категорій користувачів.
Для IoT:
	збір даних з датчиків ресурсів (вода, газ, електроенергія) для моніторингу споживання та виявлення аномалій;
	вбудована система сповіщень, яка надсилатиме повідомлення про нештатні ситуації.


1.3.2	   Рамки наступних випусків


1)	Розширена інтеграція з міськими та приватними енергосистемами.
2)	Підтримка інших мов.
3)	Багаторівнева аутентифікація користувачів.
4)	Розвиток системи екстреного реагування на критичні ситуації


1.3.3    Обмеження та Виключення


Щоб користуватися системою EcoMeChan, необхідно мати пристрій з сучасною операційною системою, як мінімум Android 6.0 або вище для мобільних пристроїв, щоб забезпечити повну функціональність та сумісність додатку. 
Незважаючи на розробку системи для стабільної роботи при різних умовах інтернет-з'єднання, для оптимальної продуктивності потрібен стабільний доступ до Інтернету. 
У першому релізі системи передбачена підтримка обмеженої кількості одночасних користувачів, що може бути розширено в майбутніх випусках. 
У разі природних катастроф, масових відключень електроенергії чи  інших надзвичайних обставин, робота системи може бути тимчасово  призупинена.
Попри прагнення до надійності, EcoMeChan може зіткнутися з рідкісними технічними помилками, що потребуватимуть оперативного усунення для відновлення повної продуктивності системи. Тому користувачам рекомендується оновлювати програмне забезпечення до найновіших версій для забезпечення оптимальної роботи системи та доступу до останніх функцій і виправлень.


1.4	Бізнес-контекст


В цьому підрозділі описано профілі зацікавлених сторін та причини їх зацікавленості, пріоритети проекту, робоче середовище, а саме технології, що використовувались при розробці.


1.4.1	    Профілі зацікавлених сторін


На таблиці 1.4.1 описані профілі зацікавлених сторін:

Таблиця 1.4.1 – Профілі зацікавлених сторін 
Зацікавлена сторона	Основне значення	Відносини	Основні інтереси	Обмеження
Міські адміністрації	Ефективне управління ресурсами	Партнерство	Оптимізація споживання, планування ресурсів, екологічність	Бюджетні обмеження, інфраструктурні вимоги
Комунальні підприємства	Зниження витрат, підвищення ефективності	Клієнт	Економія ресурсів, поліпшення управління, моніторинг	Технічні обмеження, потреба в навчанні
Кінцеві користувачі (громадяни)	Доступність та економія ресурсів	Користувач	Інтуїтивність інтерфейсу, доступ до даних, персоналізація	Доступ до технологій, освітні бар'єри
Розробники системи	Розробка та підтримка високоефективної системи	Виконавець	Технічна стабільність, розширення функціоналу, зворотний зв'язок	Ресурсні та часові обмеження
Постачальники обладнання та сервісів	Надійність і вигода від використання їхніх продуктів	Постачальник	Відповідність продуктів вимогам системи, підтримка	Логістичні та виробничі обмеження


1.4.2	   Пріоритети проєкту


На таблиці 1.4.2 наведені основні пріоритети проекту:

Таблиця 1.4.2 – Основні пріоритети проєкту 
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
Розклад	Планування, Розробка, Тестування, Випуск	6 місяців	+/− 2 тижні
Функції	Моніторинг ресурсів, Прогнозування попиту, Автоматизація управління, Централізоване управління даними	Не більше 10 основних функцій	 Від 2 до 3 додаткових функцій
Якість	Тестування на відповідність, навантаження	Максимум 5% відхилень	+/− 1%
Персонал	Розробник (одна особа)	1	0
Вартість	Розробка, Інфраструктура	до 300 американських доларів	+/− 50 американських доларів


1.4.3	   Робоче середовище


Програмна система EcoMeChan буде розроблена з використанням обраного стеку технологій. Для back-end частини буде застосовано Node.js і бази даних PostgreSQL, що забезпечать потужну та гнучку обробку даних. Для front-end розробки використовується React, що дозволить створити інтуїтивно зрозумілий інтерфейс. Мобільний застосунок буде розроблено на мові програмування Kotlin, що забезпечить високу продуктивність та надійність для Android-пристроїв. Для інтеграції з IoT датчиками буде використовуватись мікроконтролер ESP32, який надає широкі можливості для збору та передачі даних у реальному часі.
Користувачі системи EcoMeChan можуть бути географічно розпорошені, що вимагає від системи здатності функціонувати незалежно від місцезнаходження, забезпечуючи доступ 24/7 через веб-інтерфейс та мобільні додатки. Дані, згенеровані в системі, будуть централізовано зберігатися та оброблятися для забезпечення їх актуальності та цілісності. Планується, що максимальний час відгуку системи не перевищуватиме 2 секунди, щоб гарантувати швидку взаємодію користувачів з системою. Постійний доступ до EcoMeChan є критично важливим, тому будь-які перерви в роботі системи мають бути негайно усунуті, щоб забезпечити безперебійну роботу та високий рівень сервісу для користувачів. Для адміністраторів, операторів та кінцевих користувачів буде встановлено різні рівні доступу, а дані будуть зашифровані для безпеки та запобігання несанкціонованому доступу.
 
2	СЕРВЕРНА ЧАСТИНА
2.1	Моделювання програмної системи


Для аналізу функціональності програмної системи для розумного розподілення комунальними ресурсами було розроблено декілька Use Case діаграм, які відображають різні ролі в системі.
Першою для розгляду є Use Case діаграма для кінцевого користувача (громадянина) (див. додаток А, рис. A.1). На цій діаграмі представлено одного активного актора - кінцевого користувача, який має можливості для реєстрації, авторизації, перегляду історії та поточного споживання ресурсів, отримання персоналізованих рекомендацій щодо економії ресурсів, налаштування сповіщень про нештатні ситуації та перегляду і редагування особистої інформації.
Для адміністратора системи створена Use Case діаграма (див. додаток А, рис. A.2), що демонструє можливості авторизації з розширеними правами, управління обліковими записами користувачів, налаштування тарифів на ресурси, моніторингу роботи системи та управління IoT пристроями та датчиками. Розширені можливості включають створення, редагування та видалення облікових записів, перегляд статистики використання та помилок і збоїв.
Use Case діаграма для муніципального менеджера ресурсів (див. додаток А, рис. A.3) включає авторизацію з правами муніципального управління, моніторинг споживання ресурсів на рівні міста, перегляд історії споживання та подій системи, а також управління профілем користувача. Розширення функціоналу менеджера включає виявлення нештатних ситуацій, порівняння фактичного та прогнозованого споживання, фільтрацію даних за типом ресурсу та часовим періодом, фільтрацію подій за типом та пошук за ключовими словами, зміну особистих даних та паролю.
Кожна з цих Use Case діаграм представляє собою комплексний підхід до різних аспектів взаємодії учасників з системою, забезпечуючи глибоке розуміння потреб кожного актора та їх взаємодій з системою.
Для глибшого розуміння взаємодії між користувачами та системою була розроблена діаграма взаємодії для отримання статистики споживання ресурсів (див. додаток А, рис А.4).
На даній діаграмі можна побачити послідовність дій користувача. Процес починається з авторизації користувача в системі. Далі користувач надсилає запит на отримання історії споживання ресурсів. Система обробляє ці дані, виявляє аномалії, використовуючи визначення базової норми споживання, та розраховує сумарну вартість споживання за період з урахуванням зміни тарифів. Користувач отримує статистику споживання ресурсів з виявленими аномаліями та розрахованою вартістю.


2.2	Структура та взаємозв’язки у базі даних


Процес моделювання даних для програмної системи для розумного розподілення комунальними ресурсами передбачає визначення основних сутностей системи та встановлення логічних взаємозв'язків між ними. Можемо ідентифікувати такі ключові сутності: користувач, історія споживання, сповіщення, пристрій IoT, показник датчика та тариф.
Сутність «Користувач» включає атрибути, такі як унікальний ID, логін, пароль, телефон, електронна пошта, прізвище, ім'я, по батькові та роль, що дозволяє ідентифікувати та управляти правами доступу кінцевих користувачів, адміністраторів та муніципальних менеджерів.
«Історія споживання» містить деталі про спожиті ресурси, такі як ID користувача, ID тарифу, дата, тип ресурсу, кількість та вартість спожитого ресурсу. Ця сутність служить для зберігання та аналізу даних про споживання ресурсів кожним користувачем.
«Сповіщення» є важливою сутністю для інформування користувачів про стан системи та пристроїв IoT. Вона містить ID користувача, ID пристрою IoT, тип сповіщення (нормальна робота, попередження, критична ситуація), текст сповіщення, дату та час створення.
Сутність «Пристрій IoT» представляє фізичні пристрої, встановлені для моніторингу споживання ресурсів. Вона включає ID пристрою, назву, тип (датчик води, газу, електроенергії) та статус (активний, неактивний).
«Показник датчика» зберігає дані, отримані з пристроїв IoT, такі як ID пристрою, дату та час, значення показника. Ця сутність є важливою для аналізу та виявлення аномалій у споживанні ресурсів.
«Тариф» містить інформацію про ціни на ресурси, включаючи ID тарифу, назву, тип ресурсу, ціну за одиницю, дату початку та закінчення дії. Ця сутність дозволяє гнучко налаштовувати тарифи та розраховувати вартість спожитих ресурсів.
Між сутностями існують логічні зв'язки. Користувач має зв'язок «один до багатьох» з історією споживання та сповіщеннями. Історія споживання пов'язана з тарифом зв'язком «багато до одного». Сповіщення та показник датчика мають зв'язок "багато до одного" з пристроєм IoT.
Для глибшого розуміння структури бази даних та зв'язків між сутностями, можна розглянути модель в додатку А на рисунку А.5.

2.3	Розробка архітектури проекту


Архітектура програмної системи EcoMeChan була розроблена з урахуванням найкращих інженерних практик та сучасних вимог до високопродуктивних систем управління даними. Серверна частина базується на ASP.Net Core, яка відома своєю високою продуктивністю та легкістю впровадження.
Взаємодія між сервером та клієнтами в системі відбувається через REST API, гарантуючи безпеку та ефективність доступу до її функціональності. REST методи, такі як GET для вибірки даних, POST для створення записів, PUT для оновлення існуючих даних, та DELETE для видалення, були ретельно сплановані для кожного аспекту системи, починаючи від реєстрації користувачів і до управління IoT пристроями та датчиками. У таблиці 2.3 продемонстровано специфікацію REST API відповідно до програмного застосунку.

Таблиця 2.3  - Специфікація REST API
 /api/[controller]                                  	 POST    	 Створення нового запису                                           
 /api/[controller]/{id}                             	 GET     	 Отримання запису за ідентифікатором                               
 /api/[controller]                                  	 GET     	 Отримання всіх записів                                           
 /api/[controller]/{id}                             	 PUT     	 Оновлення запису за ідентифікатором                               
 /api/[controller]/{id}                             	 DELETE  	 Видалення запису за ідентифікатором                               
 /api/User/authenticate                             	 POST    	 Аутентифікація користувача                                        
 /api/User/logout                                   	 POST    	 Вихід з системи                                                   
 /api/Consumption/user/{userId}                     	 GET     	 Отримання записів споживання для користувача                     
 /api/ConsumptionCost/total-cost                    	 GET     	 Отримання загальної вартості споживання за період                 
 /api/ConsumptionNorm/calculate                     	 POST    	 Розрахунок норми споживання                                       
 /api/ConsumptionNorm/detect-anomalies              	 GET     	 Виявлення аномалій споживання                                     
 /api/IoTDevice                                     	 GET     	 Отримання всіх IoT пристроїв                                      
 /api/Notification/user/{userId}                    	 GET     	 Отримання сповіщень для користувача                               
 /api/SensorData/device/{deviceId}                  	 GET     	 Отримання даних датчиків для пристрою                             
 /api/Tariff/resourceType/{resourceType}            	 GET     	 Отримання тарифів за типом ресурсу                                
 /api/User/login/{login}                            	 GET     	 Отримання користувача за логіном                                  

Архітектурні рішення, прийняті в процесі розробки системи EcoMeChan, були спрямовані на підтримку легкої масштабованості та розширення в майбутньому. З огляду на потребу в обробці великої кількості даних, було прийнято рішення про використання реляційної бази даних PostgreSql, яка добре зарекомендувала себе у великих і середніх проектах завдяки своїй надійності та продуктивності.
Програмний продукт використовує AutoMapper для зручної трансформації даних між різними моделями, що значно спрощує мапінг об'єктів і зменшує кількість коду. Для забезпечення безпеки криптографічних операцій використовується Cryptography.KeyDerivation. Ця бібліотека дозволяє безпечно зберігати паролі користувачів, використовуючи надійне хешування. Для взаємодії з базою даних використовується Entity Framework Core, який пропонує зручний та потужний механізм для роботи з базою даних PostgreSql через лінійні запити та зміни в схемі бази даних.
Для демонстрації та тестування API використовується Swagger UI, який інтегрований у ASP.Net Core проекти та дозволяє легко перевіряти та документувати всі REST методи. Всі запити та відповіді API передаються у форматі JSON, що забезпечує легкість обміну даними та їх інтеграцію з клієнтськими додатками. Серверна частина також підтримує HTTPS для захисту даних під час передачі, а автентифікація та авторизація користувачів забезпечуються через систему токенів, що додає додатковий рівень безпеки.
Принципи взаємодії серверної частини з іншими компонентами системи зображено на діаграмі розгортання (див. додаток А, рис. A.6).
Використання сучасних фреймворків та бібліотек також забезпечує відповідність системи найновішим вимогам до безпеки та продуктивності програмного забезпечення. EcoMeChan планується розвивати й надалі, додаючи нові функції та інтегруючи з іншими системами для більш комплексного вирішення питань енергоефективності.


2.4	Програмна розробка системи


На основі ER-діаграми, яка відображає структуру бази даних і зв'язки між її елементами, були розроблені класи-моделі для системи EcoMeChan. Для прикладу, розглянемо клас Consumption (усі інші класи мають схожу структуру):
1 public class Consumption
2 {
3     public int Id { get; set; }
4     public int UserId { get; set; }
5     public int TariffId { get; set; }
6     public DateTime Date { get; set; }
7     public ResourceType ResourceType { get; set; }
8     public decimal ConsumedAmount { get; set; }
9     public decimal ConsumedCost { get; set; }
10 
11     public User User { get; set; }
12     public Tariff Tariff { get; set; }
13 };
У цьому класі присутні поля, які безпосередньо відображають атрибути в базі даних (рядки 3-9), а також спеціальні поля для встановлення зв'язків з іншими об'єктами у базі даних (рядки 11-12), використовуючи Entity Framework Core. Така структура полягає у забезпеченні інтеграції моделей з базою даних, що дозволяє системі ефективно виконувати CRUD-операції.
Для взаємодії з базою даних був створений інтерфейс репозиторію, який визначав необхідні методи для роботи з даними. Далі була реалізована імплементація цього інтерфейсу, де кожен метод був конкретизований для виконання операцій з базою даних. Цей репозиторій не був використаний безпосередньо в контролерах, але замість цього застосовувався у сервісах для обробки бізнес-логіки. Такий підхід забезпечує розділення відповідальностей і сприяє чистоті коду.
Для ефективного обміну даними між різними рівнями програмної системи було використано підхід Data Transfer Object (DTO). Завдяки AutoMapper, що дозволяє легко трансформувати об'єкти одного типу в інший, створити DTO для безпечного обміну даними, що запобігає витоку конфіденційної інформації та забезпечує оптимізацію передачі лише необхідних даних.
Всі моделі, що представляють собою таблиці бази даних, були включені до класу ApplicationDataContext, що наслідується від класу DataContext. У цьому класі вони використовуються як поля для створення таблиць, встановлення зв'язків між ними, та ініціалізації початковими даними. Екземпляр ApplicationDataContext використовується в реалізаціях репозиторіїв кожної моделі, унаслідувавши від загального репозиторію. Такий підхід забезпечує централізоване управління даними та їхню інтеграцію з різними компонентами системи.
У системі EcoMeChan безпека користувацьких паролів забезпечена за рахунок використання хешування. Процес хешування паролів реалізовано у класі UserService (див. додаток Б.1 рядок 69). Коли користувач створюється, його пароль хешується методом HashPassword (див. додаток Б.1 рядки 94-109). У цьому методі спочатку генерується сіль (GenerateSalt), після чого використовується функція PBKDF2 (HashUsingPbkdf2) для створення хешу пароля з цією сіллю.
У рядку 84 (див. додаток Б.1) відбувається перевірка пароля, введеного користувачем, з використанням методу VerifyPassword (див. додаток Б.1 рядки 121-146). Цей метод спочатку витягує сіль і хеш з збереженого хешованого пароля користувача, а потім порівнює його з хешем введеного пароля, використовуючи ту ж саму сіль.
Такий підхід безпечно зберігати пароль та легко верифікувати його, оскільки хешування робить неможливим зворотнє відтворення оригінального пароля, а сіль захищає від атак з використанням готових таблиць хешів.
У процесі розробки системи були використані різні патерни проектування для забезпечення гнучкості, розширюваності та підтримки коду. Зокрема, були застосовані наступні патерни:
Стратегія (Strategy): Цей патерн використовується для розрахунку вартості спожитих ресурсів залежно від типу тарифу. Інтерфейс ITariffStrategy визначає метод CalculateCost, який реалізується конкретними стратегіями (WaterTariffStrategy, GasTariffStrategy, ElectricityTariffStrategy) для кожного типу тарифу. Це дозволяє легко додавати нові типи тарифів без зміни основної логіки розрахунку вартості (див. додаток Б.2).
Шаблонний метод (Template Method): Цей патерн застосовується для визначення базової норми споживання та виявлення аномалій. Абстрактний клас ConsumptionNormCalculator визначає шаблонний метод CalculateNorm, який задає загальний алгоритм розрахунку норми споживання, а конкретні реалізації (StandardDeviationCalculator, AverageDeviationCalculator) реалізують специфічні кроки алгоритму (див. додаток Б.3).
Компонувальник (Composite): Цей патерн використовується для розрахунку сумарної вартості споживання за період з урахуванням зміни тарифів. Інтерфейс IConsumptionComponent визначає метод CalculateCost, який реалізується класами DayConsumption (представляє споживання за один день) та PeriodConsumption (представляє споживання за період). Клас PeriodConsumption містить список об'єктів DayConsumption і делегує розрахунок вартості до кожного дня споживання, а потім сумує результати (див. додаток Б.4).
Крім того, у системі використовується архітектурний підхід Repository-Service-Controller. Репозиторії (Repository) відповідають за взаємодію з базою даних і надають методи для отримання, збереження та оновлення даних. Сервіси (Service) містять бізнес-логіку і використовують репозиторії для доступу до даних. Контролери (Controller) обробляють HTTP-запити, викликають відповідні методи сервісів і повертають результати.
Таким чином, програмна реалізація системи EcoMeChan базується на принципах SOLID, використовує патерни проектування для забезпечення гнучкості та розширюваності, а також застосовує архітектурний підхід Repository-Service-Controller для чіткого розділення відповідальностей між компонентами системи. Використання ефективних методів хешування та солі для зберігання паролів у системі EcoMeChan забезпечує високий рівень безпеки та захисту даних користувачів від можливих атак та несанкціонованого доступу. Ретельне застосування патернів проектування та архітектурних принципів під час розробки програмного забезпечення створює надійну та масштабовану систему, здатну задовольнити потреби користувачів у довгостроковій перспективі.


2.5	Створення резервних копій бази даних


Для забезпечення надійності та безпеки даних в системі EcoMeChan передбачено механізм створення резервних копій бази даних PostgreSQL. Резервне копіювання може виконуватися як вручну, так і автоматично за розкладом з використанням вбудованого планувальника pgAdmin. Процес резервного копіювання включає вибір бази даних, налаштування параметрів резервної копії (формат, рівень стиснення, кодування) та визначення розкладу (частота, час початку, часовий пояс). Створені резервні копії можуть бути використані для відновлення бази даних у разі збоїв або втрати даних. 
3	   РОЗУМНИЙ ПРИСТРІЙ (ПРИСТРІЙ IOT)
3.1	Моделювання програмної системи


Для детального розуміння взаємодії між різними складовими програмного продукту EcoMeChan були розроблені UML діаграми прецедентів (додаток А, рисунок А.6 - А.7), що відображають основні функції та взаємозв'язки в системі.
Для актора «Контролер» (додаток А, рисунок А.6), що представляє мікроконтролер, основні сценарії включають зчитування даних з сенсорів, таких як датчики витрати води, електроенергії та газу, обчислення відповідних показників, перетворення одиниць вимірювання та порівняння з допустимими значеннями для кожного ресурсу. Також включено функції взаємодії з сервером, які охоплюють надсилання повідомлень, отримання даних про користувача, ресурси, тарифи та ціни, а також авторизацію користувачів.
Актор «Користувач» (додаток А, рисунок А.7) в системі включає можливості встановлення конфігураційних параметрів для мікроконтролера, налаштування Wi-Fi з'єднань, визначення частоти зчитування та відправлення даних, а також редагування детальних параметрів сенсорів і мережі. 
Варто зазначити, що взаємодія між користувачем та системою EcoMeChan не обмежується лише налаштуванням параметрів. Користувач також має змогу переглядати статистику споживання ресурсів, отримувати сповіщення про відхилення від норми та аналізувати витрати за певний період. Ці функції забезпечують користувачу повний контроль над споживанням ресурсів та дозволяють приймати обґрунтовані рішення щодо їх економії.
Функціональність програми представлена на UML діаграмі діяльності (додаток А, рисунок А.8), де можна побачити, що IoT-пристрій виконує зчитування даних з датчиків витрати ресурсів, обчислює показники та спілкується з сервером для передачі повідомлень від мікроконтролера та отримання даних про користувача, ресурси, тарифи та ціни.
Цілісний цикл роботи системи EcoMeChan описується таким чином:
1. Користувач спочатку налаштовує мережеві параметри IoT-пристрою локально. Після цього, пристрій звертається до сервера для отримання даних для подальшого використання у мікроконтролері.
2. Починається збір даних з сенсорів витрати води, електроенергії та газу, їх обробка та надсилання на сервер. Цей процес включає отримання та аналіз показників витрат ресурсів, порівняння їх з допустимими значеннями для кожного ресурсу та відправлення повідомлень про будь-які відхилення.
3. Розраховується споживання ресурсів за визначений період та відповідні витрати згідно встановлених тарифів, що важливо для статистичного аналізу та оновлення інформації для користувача.
Кожен з цих етапів детально представлений на UML діаграмі взаємодії (додаток А, рисунок А.9), яка ілюструє взаємодію між компонентами системи та послідовність дій, необхідних для їх виконання. Це дозволяє забезпечити глибоке розуміння процесів, що відбуваються в системі, та спрощує подальше налаштування та управління EcoMeChan.


3.2	Взаємодія між частинами системи


Інтеграція IoT-пристрою в системі EcoMeChan із сервером забезпечує централізований обмін даними та управління командами. Серверна частина, яка є мостом між IoT-пристроями та іншими компонентами системи, керує процесами збору даних про витрати комунальних ресурсів -- води, електроенергії та газу. Отримані від сенсорів дані аналізуються сервером з метою виявлення відхилень від норм споживання, і у випадку критичних змін, відправляється повідомлення до сервера через визначені методи.
Для наочності процесу обробки та обміну даними між IoT-пристроєм і сервером було розроблено UML-діаграму діяльності, яка відображає кроки взаємодії та логіку обробки інформації (див. додаток А, рисунок А.9). Ця діаграма детально демонструє як IoT-пристрій спілкується з сервером, як відбувається запис даних в базу, їх аналіз, розрахунок витрат згідно тарифів, а також механізм реагування на виявлені несправності чи відхилення в показниках споживання ресурсів. 
Сервер також відповідає за зберігання та надання актуальної інформації про тарифи та ціни на комунальні ресурси, яка використовується IoT-пристроєм для розрахунку витрат користувача. При зміні тарифів, сервер оновлює дані і відправляє їх на пристрій, забезпечуючи точність обчислень.
Ще однією важливою функцією серверу є управління обліковими записами користувачів. При ініціалізації IoT-пристрою, він звертається до серверу для автентифікації користувача та отримання його персональних даних, таких як ідентифікатор, ім'я, адреса тощо. Ці дані необхідні для коректної роботи системи та формування деталізованих звітів про споживання ресурсів для конкретного користувача.
Завдяки цій діаграмі можна ознайомитись з послідовністю обробки даних та керування подіями в системі EcoMeChan. Вона ілюструє тісну взаємодію між IoT-пристроєм, який є джерелом первинних даних про витрати ресурсів, та сервером, що виконує роль центрального вузла обробки, аналізу та зберігання інформації. Така архітектура дозволяє ефективно управляти процесом моніторингу споживання ресурсів, забезпечуючи користувачів актуальними даними та можливістю контролювати свої витрати.


3.3	Архітектура програмної системи


Програмне забезпечення для EcoMeChan було розроблено з використанням мови програмування C++ у середовищі Arduino у симуляторі Wokwi. Для моделювання фізичної системи обрано мікроконтролер ESP32, який відзначається вбудованим Wi-Fi модулем, необхідним для з'єднання з мережею та взаємодії з серверною частиною системи EcoMeChan. В якості основних сенсорів використовуються фоторезистори (LDR) для моніторингу споживання води, газу та електроенергії.
В програмній частині проекту використовуються різні бібліотеки для оптимізації роботи та забезпечення необхідних функцій. Серед них -- бібліотека HTTPClient для реалізації HTTP запитів до сервера, ArduinoJson для обробки JSON даних отриманих від сервера, Effortless-SPIFFS та SD для роботи з файловою системою та зберігання конфігураційних параметрів.
Архітектура програмної системи EcoMeChan базується на принципах модульності та розподілу відповідальності. Код розділений на окремі файли та класи, кожен з яких відповідає за певну функціональність. Файли config.h та config.json містять конфігураційні параметри системи, такі як піни підключення сенсорів, налаштування Wi-Fi, адреси серверу тощо. Файл authentication_service.cpp відповідає за автентифікацію користувача на сервері, тоді як data_collection_service.cpp здійснює збір даних з сенсорів та відправку їх на сервер. Файл consumption_repository.cpp виконує операції з даними про споживання ресурсів, такі як перетворення одиниць вимірювання, а tariff_repository.cpp забезпечує отримання даних про тарифи з серверу. Файл notification_service.cpp відповідає за відправку сповіщень та статистики на сервер, а analytics_service.cpp здійснює розрахунок статистичних показників споживання ресурсів. Файл sensor_service.cpp містить функції для зчитування даних з сенсорів, а user_singleton.h реалізує шаблон Singleton для зберігання даних про користувача. Файл utils.cpp містить допоміжні функції, такі як форматування дати та часу.
Така архітектура забезпечує гнучкість, можливість розширення функціоналу та зручність підтримки коду. Модульний підхід дозволяє легко додавати нові функції, змінювати існуючі та проводити тестування окремих компонентів системи.


3.4	Програмна розробка системи


Перед початком написання коду для системи EcoMeChan було ретельно сплановано фізичне підключення компонентів: сенсорів та мікроконтролера (див. додаток А, рисунок А.10). У конструкції використовується мікроконтролер ESP32, до якого підключені фоторезистори (LDR) для збору даних про споживання води, газу та електроенергії, під'єднані до GPIO33, GPIO34 та GPIO35 відповідно. Також до мікроконтролера підключено microSD картку через відповідні піни для зберігання конфігураційних параметрів.
По завершенню фізичної побудови системи, починається етап написання програмного коду. На цьому етапі ініціюється оголошення глобальних змінних, які використовуватимуться в усьому коді для зберігання зібраних даних з сенсорів і для налаштування мережевих параметрів. Це включає інформацію для з'єднання з Wi-Fi мережею, таку як SSID та пароль, параметри сервера, включаючи його URL та ідентифікатори IoT пристроїв. Також встановлюються інтервали часу для зчитування даних з сенсорів, відправки даних на сервер та розрахунку статистики.
Метод setup() ініціалізує систему, здійснюючи підключення до Wi-Fi, синхронізацію часу через NTP сервер та автентифікацію користувача. Цей процес описується у файлі sketch.ino (див. додаток Б.5, рядки 35-69).
Метод loop() відповідає за постійне зчитування даних із сенсорів та відправлення їх на сервер для оновлення бази даних. Він також включає логіку порівняння отриманих даних із заданими пороговими значеннями для кожного ресурсу, і в разі виявлення перевищень, ініціює відправлення повідомлень через метод sendNotificationToServer(). Процес зчитування даних та їх відправки описано в методі loop() у файлі sketch.ino (див. додаток Б.5, рядки 74-162).
Окрім цього, в архітектурі програмної системи EcoMeChan були застосовані певні шаблони проектування та архітектурні рішення для покращення якості коду та його підтримки. Система була розділена на логічні частини, кожна з яких відповідає за певну функціональність, що відображено в структурі файлів та класів. Наприклад, класи TariffRepository та ConsumptionRepository (див. додаток Б.6 та Б.7) реалізують шаблон Repository для доступу до даних тарифів та споживання з серверу. Вони інкапсулюють логіку взаємодії з сервером та надають зручний інтерфейс для отримання необхідних даних.
Також, було застосовано шаблон Singleton для глобальних об'єктів, таких як Config (див. додаток Б.8) та User (див. додаток Б.9). Це забезпечує наявність лише одного екземпляру цих об'єктів в системі та зручний доступ до них з різних частин програми.
Функції sendSensorDataToServer() (див. додаток Б.10, рядки 10-41), sendConsumptionToServer() (див. додаток Б.11, рядки 43-75) та sendNotificationToServer() (див. додаток Б.12, рядки 9-44) є частиною сервісу збору даних та відправки їх на сервер. Вони інкапсулюють логіку формування JSON payload та виконання HTTP запитів.
Функції calculateConsumptionStats() (див. додаток Б.13, рядки 8-41) та formatStatsMessage() (див. додаток Б.13, рядки 43-56) відповідають за розрахунок статистичних показників споживання ресурсів та формування текстових повідомлень зі статистикою. Вони є частиною сервісу аналітики та статистики. 
4	   КЛІЄНТСЬКА ЧАСТИНА (ФРОНТЕНД ЧАСТИНА)
4.1	Моделювання програмної системи


Для розгляду функціональності фронтенд частини програмної системи для розумного розподілення комунальними ресурсами «EcoMeChan» було розроблено декілька UML діаграм прецедентів для ілюстрації взаємодій різних ролей з системою. У цих діаграмах відображені особливості взаємодії для ролей кінцевого користувача та адміністратора, а також деталізовано відображено процеси, пов'язані з керуванням особистими кабінетами користувачів та IoT пристроями.
Діаграма прецедентів для кінцевого користувача (додаток А, рис. А.11) ілюструє важливі взаємодії, такі як реєстрація, авторизація в системі, перегляд актуальної інформації про споживання ресурсів, історії споживання ресурсів, персоналізація інтерфейсу, зміна мови інтерфейсу (українська, англійська), перегляд IoT пристроїв для цього користувача, перегляд та редагування персональних даних (ПІБ, електронна пошта, номер телефону).
Для адміністраторів системи, діаграма прецедентів (додаток А, рис. А.12) демонструє можливості авторизації в системі, управління IoT пристроями (перегляд, створення нових, редагування даних, видалення), моніторинг помилок та збоїв від IoT, адміністрування користувачами (перегляд, створення нових, редагування даних, видалення) та створення резервних копій.
Також було розроблено UML діаграму активності для адміністраторів (додаток А, рисунок А.13), яка представляє дії, пов'язані з особистими кабінетами користувачів, включаючи перегляд списку користувачів, деталей профілів, додавання, видалення, та редагування облікових записів.
Ці діаграми надають детальне уявлення про взаємодії між різними користувачами та компонентами системи «EcoMeChan», сприяючи кращому розумінню функціональності та взаємодій в рамках даної системи.


4.2	Взаємодія між частинами системи


Взаємодія фронтенд частини «EcoMeChan» з іншими частинами системи відбувається через серверну частину, яка використовує .NET і PostgreSQL для роботи з базами даних. Фронтенд відповідає за представлення інтерфейсу користувача, дозволяючи кінцевим користувачам і адміністраторам виконувати такі дії, як реєстрація, авторизація, перегляд інформації про споживання ресурсів, управління IoT пристроями, перегляд та редагування персональних даних. Всі ці функції інтегровані з серверною частиною, яка обробляє запити, забезпечує безпеку даних, централізовано зберігає та обробляє дані користувачів та IoT пристроїв, а також адмініструє права доступу різних категорій користувачів.
Для ілюстрації взаємодії між фронтенд частиною та серверною частиною, можна розглянути UML діаграму взаємодії для процесу управління даними користувачів (додаток А, рисунок А.14). На цій діаграмі відображається послідовність взаємодії між фронтенд частиною, серверною частиною та базою даних. Це включає запити на перегляд списку користувачів, деталей профілів, додавання, редагування та видалення користувачів. Фронтенд відправляє відповідні запити до серверної частини, яка в свою чергу взаємодіє з базою даних для отримання, оновлення або видалення інформації про користувачів. Після обробки запиту, серверна частина відправляє результат назад до фронтенд, де він відображається адміністратору.


4.3	Архітектура програмної системи


Фронтенд частина програмної системи «EcoMeChan» була розроблена з використанням бібліотеки React, яка базується на компонентній архітектурі та дозволяє створювати масштабовані та ефективні веб-застосунки. В якості мови програмування використовується JavaScript, а для стилізації компонентів застосовується CSS.
Структура проекту організована відповідно до принципів розділення відповідальності та модульності. Директорія «src» містить основні файли та підкаталоги, необхідні для роботи застосунку.
Компоненти розміщені в директорії «components» і розділені на окремі файли відповідно до їх функціональності. Наприклад, компоненти Header, Footer та LanguageSelector відповідають за відображення шапки, підвалу сторінки та вибір мови інтерфейсу. Компонент UserForm використовується для відображення форми редагування даних користувача.
Сторінки застосунку знаходяться в директорії «pages» і також розділені за функціональним призначенням. Наприклад, сторінки Home, About, Services, Contacts відповідають за відображення головної сторінки, інформації про систему, послуг та контактних даних. Сторінки для авторизації та реєстрації розміщені в окремих файлах Login.js та Registration.js. Сторінки для різних ролей користувачів (адміністратора та звичайного користувача) розміщені у відповідних підкаталогах «admin» та «user».
Для зберігання глобального стану та забезпечення доступу до нього з різних компонентів використовуються контексти, які знаходяться в директорії «contexts». Зокрема, AuthContext відповідає за зберігання даних про автентифікацію користувача, а LanguageContext - за вибір мови інтерфейсу.
Константи та перелічувані типи, які використовуються в різних частинах застосунку, винесені в окрему директорію «enums». Наприклад, перелічуваний тип Role визначає можливі ролі користувачів в системі.
Для забезпечення багатомовності інтерфейсу використовується бібліотека react-intl, а файли з перекладами знаходяться в директорії «locales».
Сервіси для взаємодії з серверною частиною розміщені в директорії «services». Вони використовують бібліотеку axios для надсилання HTTP-запитів до API.
Допоміжні функції та утиліти, які використовуються в різних частинах застосунку, знаходяться в директорії «utils». Наприклад, функції для форматування дати та часу, а також для визначення стану та типу IoT-пристроїв.
Для стилізації компонентів та сторінок використовуються окремі файли стилів, які знаходяться в директорії «styles».
Конфігураційні файли, такі як config.json та setupTests.js, розміщені в кореневій директорії проекту.
В процесі розробки використовувалися різноманітні бібліотеки та інструменти, такі як react-router-dom для маршрутизації, bootstrap для стилізації компонентів, date-fns для роботи з датами, axios для надсилання HTTP-запитів.
Завдяки модульній структурі та розділенню відповідальності між компонентами, сторінками та сервісами, фронтенд частина «EcoMeChan» є масштабованою, зручною для підтримки та розширення функціональності.


4.4	Програмна розробка системи


Для візуалізації взаємодії моделей (класів) між собою було розроблено діаграму компонентів (додаток А, рис. А.15).
Процес розробки фронтенд частини програмної системи «EcoMeChan» поєднує різноманітні аспекти програмування, що гарантує її ефективність та зручність. В основі розробки лежить дотримання принципів чистого коду, що включає належне форматування, коментування та іменування елементів. Наприклад, у компоненті Header (див. додаток Б.14, строки 9-40), де формується заголовок застосунку, код чітко розбитий на блоки, із зрозумілими коментарями, які пояснюють кожен крок. Це спрощує розуміння логіки роботи компоненту та його подальшу модифікацію чи відладку.
Критично важливим елементом є обробка помилок, зокрема використання конструкцій try-catch, які дозволяють ефективно управляти винятковими ситуаціями без зупинки всієї системи. У сервісі AuthService (див. додаток Б.15, строки 4-29) цей принцип впроваджено для гарантії безперебійної роботи навіть у випадку непередбачених помилок, таких як некоректні дані користувача або проблеми з мережею.
Локалізація та інтернаціоналізація відіграють ключову роль у забезпеченні доступності та зручності для широкого кола користувачів. Використовуючи бібліотеку react-intl та файли перекладів у форматі JSON (див. додатки Б.16-17), фронтенд частина «EcoMeChan» забезпечує підтримку багатьох мов, що дозволяє користувачам працювати із системою у звичному для них мовному середовищі.
Облік часу в системі також важливий, зокрема у контексті міжнародного використання. Завдяки використанню бібліотеки date-fns та утиліт, таких як DateUtils (див. додаток Б.18), фронтенд застосунок здатен обробляти різні формати дати та часу, забезпечуючи коректне відображення інформації залежно від локалі користувача.
Робота з даними та їх структурами у «EcoMeChan» також відповідає високим стандартам. Наприклад, у компоненті UserConsumptionHistoryPage (див. додаток Б.19, строки 52-58) використовуються функції форматування та перетворення одиниць вимірювання для зручного відображення даних про споживання ресурсів користувачем.
Архітектура фронтенд частини «EcoMeChan» базується на сучасних підходах та принципах розробки програмного забезпечення. Вона включає в себе компонентно-орієнтовану архітектуру, поділ відповідальності, принцип єдиної відповідальності (SRP), ін'єкцію залежностей (DI), принцип DRY, архітектуру "клієнт-сервер" та маршрутизацію.
Компонентно-орієнтована архітектура реалізована через структурування проєкту за допомогою компонентів React, де кожен компонент представляє собою багаторазовий і самодостатній елемент інтерфейсу користувача. Поділ відповідальності досягається через розділення різних аспектів на окремі шари і компоненти, такі як каталоги pages, components, services та contexts.
Принцип єдиної відповідальності (SRP) реалізовано через призначення конкретних обов'язків кожному компоненту та модулю, наприклад, компонент Header відповідає за відображення заголовка застосунку, а сервіс AuthService відповідає за взаємодію з API, пов'язану з аутентифікацією.
Ін'єкція залежностей (DI) здійснюється через API контексту React (AuthContext і LanguageContext) для надання залежностей компонентам, які їх потребують (див. додатки Б.19-20). Принцип DRY реалізовано через повторне використання компонентів та коду, таких як Header, Footer, LanguageSelector та UserForm. 
5	МОБІЛЬНИЙ ЗАСТОСУНОК
5.1	Моделювання програмної системи


Для розгляду функціональності мобільної частини програмної системи для розумного розподілення комунальними ресурсами «EcoMeChan» було розроблено декілька UML діаграм прецедентів для ілюстрації взаємодій різних ролей з системою. У цих діаграмах відображені особливості взаємодії для ролей кінцевого користувача та адміністратора, а також деталізовано відображено процеси, пов'язані з керуванням особистими кабінетами користувачів та IoT пристроями.
Діаграма прецедентів для кінцевого користувача (додаток А, рис. А.16) ілюструє важливі взаємодії, такі як реєстрація, авторизація в системі, перегляд актуальної інформації про споживання ресурсів, історії споживання ресурсів, персоналізація інтерфейсу, зміна мови інтерфейсу (українська, англійська), перегляд IoT пристроїв для цього користувача, перегляд та редагування персональних даних (ПІБ, електронна пошта, номер телефону).
Для адміністраторів системи, діаграма прецедентів (додаток А, рис. А.17) демонструє можливості авторизації в системі, управління IoT пристроями (перегляд, створення нових, редагування даних, видалення), моніторинг помилок та збоїв від IoT, адміністрування користувачами (перегляд, створення нових, редагування даних, видалення).
Також було розроблено UML діаграму активності для адміністраторів (додаток А, рисунок А.18), яка представляє дії, пов'язані з особистими кабінетами користувачів, включаючи перегляд списку користувачів, деталей профілів, додавання, видалення, та редагування облікових записів.
Ці діаграми надають детальне уявлення про взаємодії між різними користувачами та компонентами системи «EcoMeChan», сприяючи кращому розумінню функціональності та взаємодій в рамках даної системи.


5.2	Взаємодія між частинами системи


Взаємодія мобільної частини «EcoMeChan» з іншими частинами системи відбувається через серверну частину, яка використовує .NET і PostgreSQL для роботи з базами даних. Мобільний застосунок відповідає за представлення інтерфейсу користувача, дозволяючи кінцевим користувачам і адміністраторам виконувати такі дії, як реєстрація, авторизація, перегляд інформації про споживання ресурсів, управління IoT пристроями, перегляд та редагування персональних даних. Всі ці функції інтегровані з серверною частиною, яка обробляє запити, забезпечує безпеку даних, централізовано зберігає та обробляє дані користувачів та IoT пристроїв, а також адмініструє права доступу різних категорій користувачів.
Для ілюстрації взаємодії між мобільною частиною та серверною частиною, можна розглянути UML діаграму взаємодії для процесу управління даними користувачів (додаток А, рисунок А.21). На цій діаграмі відображається послідовність взаємодії між мобільною частиною, серверною частиною та базою даних. Це включає запити на перегляд списку користувачів, деталей профілів, додавання, редагування та видалення користувачів. Мобільний застосунок відправляє відповідні запити до серверної частини, яка в свою чергу взаємодіє з базою даних для отримання, оновлення або видалення інформації про користувачів. Після обробки запиту, серверна частина відправляє результат назад до мобільного застосунку, де він відображається адміністратору.
5.3	Архітектура програмної системи


Мобільна частина програмної системи «EcoMeChan» була розроблена з використанням фреймворку .NET MAUI (Multi-platform App UI), який дозволяє створювати крос-платформні мобільні застосунки з використанням мови програмування C#. MAUI базується на архітектурі MVVM (Model-View-ViewModel) та забезпечує розділення логіки застосунку, інтерфейсу користувача та взаємодії між ними.
Структура проекту організована відповідно до принципів MVVM та розділена на кілька ключових директорій та файлів. Директорія «Models» містить класи моделей даних, які представляють сутності предметної області, такі як User, IoTDevice, Consumption тощо. Ці класи визначають структуру даних та їх властивості. Директорія «ViewModels» містить класи, які реалізують логіку представлення та обробку даних для відповідних сторінок та компонентів інтерфейсу користувача. Наприклад, LoginViewModel відповідає за логіку авторизації користувача, а ConsumptionHistoryViewModel - за отримання та відображення історії споживання ресурсів.
Директорія «Views» містить xaml-файли, які визначають структуру та розмітку сторінок та компонентів інтерфейсу користувача. Кожна сторінка має відповідний файл, який містить логіку обробки подій та взаємодії з відповідною ViewModel. Директорія «Services» містить класи сервісів, які забезпечують взаємодію з серверною частиною системи через HTTP-запити. Наприклад, AuthService відповідає за автентифікацію користувача, а ConsumptionService - за отримання даних про споживання ресурсів.
Директорія «Enums» містить перелічувані типи, які використовуються в різних частинах застосунку, наприклад, для визначення ролей користувачів та типів сповіщень. Директорія «Resources» містить ресурси застосунку, такі як файли локалізації (AppResources.resx), які забезпечують багатомовність інтерфейсу користувача. Також в цій директорії знаходяться стилі, шрифти та зображення, які використовуються в застосунку.
Файл «App.xaml» та файл «App.xaml.cs» містять логіку ініціалізації та налаштування застосунку, такі як реєстрація сервісів та навігація між сторінками. Файл «AppShell.xaml» та файл «AppShell.xaml.cs» визначають структуру навігації застосунку та містять логіку для відображення панелі вкладок (табів) для різних ролей користувачів.
Взаємодія між компонентами застосунку здійснюється за допомогою прив'язки даних (англ. - data binding) та команд (англ. - commands). ViewModels містять властивості та команди, які прив'язуються до відповідних елементів інтерфейсу користувача у Views. Коли користувач взаємодіє з елементами інтерфейсу, виклики команд передаються до відповідних методів у ViewModels для обробки.
Для забезпечення багатомовності інтерфейсу користувача використовуються ресурсні файли локалізації (AppResources.resx), які містять переклади текстових рядків для різних мов. Застосунок автоматично обирає відповідний ресурсний файл на основі мовних налаштувань пристрою. Для взаємодії з серверною частиною використовуються HTTP-запити, які надсилаються через класи сервісів. Дані, отримані від сервера, десеріалізуються за допомогою бібліотеки Newtonsoft.Json та передаються до відповідних ViewModels для відображення в інтерфейсі користувача.
Архітектура мобільної частини «EcoMeChan» забезпечує чіткий розподіл відповідальності між компонентами, що полегшує розробку, тестування та підтримку застосунку. Використання MVVM дозволяє досягти кращої масштабованості, повторного використання коду та зручності розширення функціональності в майбутньому.


5.4	Програмна розробка системи


Для візуалізації взаємодії моделей (класів) між собою було розроблено діаграму компонентів (додаток А, рис. А.22).
Процес розробки мобільної частини програмної системи «EcoMeChan» базується на дотриманні принципів чистого коду, ефективної обробки помилок, локалізації та інтернаціоналізації, а також на використанні сучасних підходів та архітектурних шаблонів.
Код мобільного застосунку «EcoMeChan» написаний з дотриманням принципів чистого коду, що включає належне форматування, коментування та іменування елементів. Наприклад, у класі App (див. додаток Б.21, рядки 9-53) код розбитий на логічні блоки, використовуються зрозумілі назви змінних та методів, що покращує читабельність та підтримку коду.
Обробка помилок є важливим аспектом розробки мобільного застосунку. У сервісах, таких як AuthService (див. додаток Б.22, рядки 35-39), використовуються блоки try-catch для обробки виняткових ситуацій та запобігання збоїв у роботі застосунку. Це дозволяє обробляти помилки та надавати користувачам інформативні повідомлення.
Локалізація та інтернаціоналізація реалізовані з використанням ресурсних файлів та класу AppResources. Ресурсні файли містять переклади текстових рядків для різних мов, а клас AppResources надає доступ до цих рядків в коді. Це дозволяє легко адаптувати інтерфейс користувача до різних мов та культурних особливостей.
Мобільний застосунок «EcoMeChan» використовує архітектурний шаблон MVVM (Model-View-ViewModel), який забезпечує чіткий поділ відповідальності та покращує тестованість та масштабованість коду. Моделі представляють бізнес-логіку та дані, представлення (Views) відповідають за відображення інтерфейсу користувача, а моделі представлення (ViewModels) забезпечують зв'язок між моделями та представленнями.
Для забезпечення модульності та повторного використання коду, мобільний застосунок розділений на окремі сервіси, такі як AuthService (див. додаток Б.22), ConsumptionService (див. додаток Б.23), IoTDeviceService (див. додаток Б.24) тощо. Ці сервіси інкапсулюють логіку взаємодії з серверною частиною та надають зручний API для використання в інших частинах застосунку.
Для роботи з віддаленим API використовується клас HttpClient та бібліотека Newtonsoft.Json для серіалізації та десеріалізації даних у форматі JSON. Наприклад, у методі LoginAsync сервісу AuthService (див. додаток Б.22, рядки 21-40) виконується запит до серверного API для автентифікації користувача та обробляється відповідь.
В мобільному застосунку «EcoMeChan» також використовуються конвертери значень (англ. - value converters) для перетворення даних між різними типами. Наприклад, клас ResourceTypeConverter (див. додаток Б.25) використовується для перетворення значень перелічуваного типу ResourceType у рядкові представлення з урахуванням поточної мови. 
ВИСНОВКИ


На основі сучасних технологій програмування, баз даних та IoT-пристроїв була розроблена комплексна система управління ресурсами EcoMeChan. Розробка системи базувалася на комплексному аналізі потреб міських адміністрацій, комунальних підприємств та кінцевих користувачів, враховуючи вимоги до моніторингу, управління та оптимізації споживання води, електроенергії та газу.
EcoMeChan забезпечує інтегрований підхід до моніторингу, контролю та оптимізації споживання ресурсів на міському та регіональному рівнях, використовуючи передові технології для забезпечення сталого розвитку та зниження екологічного впливу. Основна мета системи полягає в оптимізації використання природних ресурсів для забезпечення сталого розвитку та мінімізації екологічного впливу. 
Система дозволяє міським адміністраціям, комунальним підприємствам та приватним користувачам оптимізувати використання ресурсів, зменшити витрати та покращити реагування на зміни у попиті та постачанні. EcoMeChan інтегрує дані від різних джерел моніторингу для забезпечення точного аналізу та управління в реальному часі, що дозволяє не лише виявляти та аналізувати тенденції споживання, але й прогнозувати майбутні потреби для попередження надлишку або нестачі ресурсів.
Впровадження EcoMeChan дозволяє містам та підприємствам не тільки знижувати екологічний вплив, але й значно покращувати свою економічну ефективність, адаптуючи споживання ресурсів до актуальних потреб і використовуючи дані для прийняття обґрунтованих рішень. Система розроблена з особливою увагою до екологічної відповідальності, прагнучи перетворити існуючі виклики у сфері управління ресурсами на нові можливості, що сприятиме не лише підвищенню ефективності, але й сталому розвитку. EcoMeChan забезпечує управління постачання ресурсів відповідно до змін у споживанні, максимізуючи ефективність та мінімізуючи витрати.
Гнучке масштабування підтримує збільшення або зменшення обсягів використання системи без втрати продуктивності або ефективності, а зручний доступ через мобільні та веб-інтерфейси забезпечує максимальну гнучкість та оперативність в управлінні ресурсами.
Реалізація системи EcoMeChan забезпечує значні покращення в організації управління ресурсами, підвищує ефективність використання ресурсів, знижує витрати та покращує якість життя громадян, роблячи ефективне управління ресурсами центральним елементом сучасного екологічного та економічного планування. 
ПЕРЕЛІК ПОСИЛАНЬ


1.	Посилання на архів з кодом: https://github.com/NureChanVadym/apz-pzpi-21-2-chan-vadym     
2.	Посилання на проект у симуляторі Wokwi:         https://wokwi.com/projects/397599564587362305 
3.	Посилання на відеозапис: https://youtu.be/PmwIKCfK15o  

 
ДОДАТОК А
Схеми та діаграми


 
Рисунок А.1 – UML діаграма прецедентів кінцевого користувача (громадянина)
 
Рисунок А.2 – UML діаграма прецедентів муніципального менеджера ресурсів
 
Рисунок А.3 – UML діаграма прецедентів адміністратора системи
 
Рисунок А.4 – UML діаграма взаємодії для отримання статистики споживання ресурсів 
Рисунок А.5 – Entity-Relationship Model діаграма
 
Рисунок А.6 – UML діаграма розгортання (Deployment Diagram)
 
Рисунок А.7 – UML діаграма прецедентів для програмної системи
 
Рисунок А.8 – UML діаграма прецедентів для користувача
 
Рисунок А.9 – UML діаграма діяльності для обробки показників
 
Рисунок А.10 – UML діаграма взаємодії для обробки показників 
Рисунок А.11 – Схема фізичної моделі
 
Рисунок А.12 – UML діаграма станів для етапу запуску (налаштувань)
 
Рисунок А.13 – UML діаграма прецедентів для кінцевого користувача
 
Рисунок А.14 – UML діаграма прецедентів для адміністратора 
 
Рисунок А.15 – UML діаграма діяльності для дій адміністратора з особистим кабінетом користувача
 
Рисунок А.16 – UML діаграма взаємодії для управління обліковими записами користувачів
 
Рисунок А.17 – UML діаграма компонентів для моделей (сутностей) програмного продукту
 
Рисунок А.18 – UML діаграма прецедентів для кінцевого користувача
 
Рисунок А.19 – UML діаграма прецедентів для адміністратора 
 
Рисунок А.20 – UML діаграма діяльності для дій адміністратора з особистим кабінетом користувача
 
Рисунок А.21 – UML діаграма взаємодії для управління обліковими записами користувачів
 
Рисунок А.22 – UML діаграма компонентів для моделей (сутностей) програмного продукту 
ДОДАТОК Б
Приклади коду


Б.1 Програмний код класу UserService


1 
2 public class UserService : IUserService
3 {
4     private readonly IUserRepository _userRepository;
5     private readonly IMapper _mapper;
6     private readonly IHttpContextAccessor _httpContextAccessor;
7 
8     public UserService(IUserRepository userRepository, IMapper mapper, IHttpContextAccessor httpContextAccessor)
9     {
10         _userRepository = userRepository;
11         _mapper = mapper;
12         _httpContextAccessor = httpContextAccessor;
13     }
14 
15 	/// <summary>
16     /// Creates a new user account.
17     /// </summary>
18     /// <param name="userCreateViewModel">The user creation view model.</param>
19     /// <returns>The view model of the created user.</returns>
20     public async Task<UserViewModel> CreateAsync(UserCreateViewModel userCreateViewModel)
21     {
22         // Validate login
23         if (string.IsNullOrWhiteSpace(userCreateViewModel.Login))
24         {
25             throw new ArgumentException("Login is required.");
26         }
27 
28         var existingUser = await _userRepository.GetByLoginAsync(userCreateViewModel.Login);
29         if (existingUser != null)
30         {
31             throw new InvalidOperationException("A user with the same login already exists.");
32         }
33 
34         // Validate email
35         if (string.IsNullOrWhiteSpace(userCreateViewModel.Email))
36         {
37             throw new ArgumentException("Email is required.");
38         }
39 
40         var emailRegex = new Regex(@"^[^@\s]+@[^@\s]+\.[^@\s]+$");
41         if (!emailRegex.IsMatch(userCreateViewModel.Email))
42         {
43             throw new ArgumentException("Invalid email format.");
44         }
45 
46         // Validate password
47         if (string.IsNullOrWhiteSpace(userCreateViewModel.Password))
48         {
49             throw new ArgumentException("Password is required.");
50         }
51 
52         if (userCreateViewModel.Password.Length < 8)
53         {
54             throw new ArgumentException("Password must be at least 8 characters long.");
55         }
56 
57         // Validate required fields
58         if (string.IsNullOrWhiteSpace(userCreateViewModel.FirstName))
59         {
60             throw new ArgumentException("First name is required.");
61         }
62 
63         if (string.IsNullOrWhiteSpace(userCreateViewModel.LastName))
64         {
65             throw new ArgumentException("Last name is required.");
66         }
67 
68         var user = _mapper.Map<User>(userCreateViewModel);
69         user.Password = HashPassword(user.Password);
70         var createdUser = await _userRepository.CreateAsync(user);
71         _httpContextAccessor.HttpContext.Response.Cookies.Append("role", createdUser.Role.ToString());
72         return _mapper.Map<UserViewModel>(createdUser);
73     }
74 
75     /// <summary>
76     /// Authenticates a user with the provided credentials.
77     /// </summary>
78     /// <param name="login">The user's login.</param>
79     /// <param name="password">The user's password.</param>
80     /// <returns>The view model of the authenticated user.</returns>	
81     public async Task<UserViewModel> AuthenticateAsync(string login, string password)
82     {
83         var user = await _userRepository.GetByLoginAsync(login);
84         if (user == null || !VerifyPassword(password, user.Password))
85         {
86             throw new InvalidOperationException("Invalid credentials.");
87         }
88         _httpContextAccessor.HttpContext.Response.Cookies.Append("role", user.Role.ToString());
89         return _mapper.Map<UserViewModel>(user);
90     }
91 
92     // ...
93 
94     private string HashPassword(string password)
95     {
96         byte[] salt = GenerateSalt();
97         string hashed = HashUsingPbkdf2(password, salt);
98         return $"{Convert.ToBase64String(salt)}.{hashed}";
99     }
100 
101     private byte[] GenerateSalt()
102     {
103         byte[] salt = new byte[128 / 8];
104         using (var rng = RandomNumberGenerator.Create())
105         {
106             rng.GetBytes(salt);
107         }
108         return salt;
109     }
110 
111     private string HashUsingPbkdf2(string password, byte[] salt)
112     {
113         return Convert.ToBase64String(KeyDerivation.Pbkdf2(
114             password: password,
115             salt: salt,
116             prf: KeyDerivationPrf.HMACSHA256,
117             iterationCount: 10000,
118             numBytesRequested: 256 / 8));
119     }
120 
121     private bool VerifyPassword(string password, string hashedPassword)
122     {
123         if (!TryExtractSaltAndHash(hashedPassword, out byte[]? salt, out string? storedHash))
124         {
125             return false;
126         }
127 
128         string hashToVerify = HashUsingPbkdf2(password, salt);
129         return hashToVerify == storedHash;
130     }
131 
132     private bool TryExtractSaltAndHash(string hashedPassword, out byte[]? salt, out string? hash)
133     {
134         var parts = hashedPassword.Split('.');
135         if (parts.Length != 2)
136         {
137             salt = null;
138             hash = null;
139             return false;
140         }
141 
142         salt = Convert.FromBase64String(parts[0]);
143         hash = parts[1];
144         return true;
145     }
146 }


Б.2 Програмний код патерну «Стратегія» для розрахунку вартості спожитих ресурсів


1 /// <summary>
2 /// Represents a strategy for calculating the cost of a resource consumption.
3 /// </summary>
4 public interface ITariffStrategy
5 {
6    /// <summary>
7    /// Calculates the cost of the consumed amount based on the provided tariff.
8    /// </summary>
9    /// <param name="consumedAmount">The amount of resource consumed.</param>
10    /// <param name="tariff">The tariff information.</param>
11    /// <returns>The calculated cost.</returns>
12    decimal CalculateCost(decimal consumedAmount, Tariff tariff);
13 }
14 
15 public class WaterTariffStrategy : ITariffStrategy
16 {
17     public decimal CalculateCost(decimal consumedAmount, Tariff tariff)
18     {
19         if (tariff.ResourceType != ResourceType.Water)
20         {
21             throw new InvalidOperationException("Invalid tariff type for water consumption.");
22         }
23 
24         return consumedAmount * tariff.PricePerUnit;
25     }
26 }
27 
28 public class GasTariffStrategy : ITariffStrategy
29 {
30     public decimal CalculateCost(decimal consumedAmount, Tariff tariff)
31     {
32         if (tariff.ResourceType != ResourceType.Gas)
33         {
34             throw new InvalidOperationException("Invalid tariff type for gas consumption.");
35         }
36 
37         return consumedAmount * tariff.PricePerUnit;
38     }
39 }
40 
41 public class ElectricityTariffStrategy : ITariffStrategy
42 {
43     public decimal CalculateCost(decimal consumedAmount, Tariff tariff)
44     {
45         if (tariff.ResourceType != ResourceType.Electricity)
46         {
47             throw new InvalidOperationException("Invalid tariff type for electricity consumption.");
48         }
49         return consumedAmount * tariff.PricePerUnit;
50     }
51 }


Б.3 Програмний код патерну "Шаблонний метод" для визначення базової норми споживання


1 /// <summary>
2 /// Provides a base implementation for calculating consumption norms and detecting anomalies.
3 /// </summary>
4 public abstract class ConsumptionNormCalculator
5 {
6     /// <summary>
7     /// Calculates the consumption norm based on the provided consumption data.
8     /// </summary>
9     /// <param name="consumptionData">The collection of consumption data.</param>
10     /// <returns>The calculated consumption norm.</returns>
11     public ConsumptionNorm CalculateNorm(IEnumerable<Consumption> consumptionData)
12     {
13         if (consumptionData == null || !consumptionData.Any())
14         {
15             throw new ArgumentException("Consumption data cannot be null or empty.", nameof(consumptionData));
16         }
17 
18         var baseline = CalculateBaseline(consumptionData);
19         var deviation = CalculateDeviation(consumptionData, baseline);
20 
21         return new ConsumptionNorm { BaselineConsumption = baseline, StandardDeviation = deviation };
22     }
23 
24     /// <summary>
25     /// Calculates the deviation from the baseline consumption based on the provided consumption data.
26     /// </summary>
27     /// <param name="consumptionData">The collection of consumption data.</param>
28     /// <param name="baseline">The baseline consumption value.</param>
29     /// <returns>The calculated deviation.</returns>
30     protected abstract decimal CalculateDeviation(IEnumerable<Consumption> consumptionData, decimal baseline);
31 
32     /// <summary>
33     /// Calculates the baseline consumption based on the provided consumption data.
34     /// </summary>
35     /// <param name="consumptionData">The collection of consumption data.</param>
36     /// <returns>The calculated baseline consumption.</returns>
37     protected decimal CalculateBaseline(IEnumerable<Consumption> consumptionData)
38     {
39         if (consumptionData == null || !consumptionData.Any())
40         {
41             throw new ArgumentException("Consumption data cannot be null or empty.", nameof(consumptionData));
42         }
43 
44         return consumptionData.Average(c => c.ConsumedAmount);
45     }
46 
47     /// <summary>
48     /// Determines whether the current consumption is an anomaly based on the provided baseline and deviation.
49     /// </summary>
50     /// <param name="currentConsumption">The current consumption value.</param>
51     /// <param name="baselineConsumption">The baseline consumption value.</param>
52     /// <param name="deviation">The deviation from the baseline.</param>
53     /// <returns>True if the current consumption is an anomaly, otherwise false.</returns>
54     public abstract bool IsAnomaly(decimal currentConsumption, decimal baselineConsumption, decimal deviation);
55 }
56 
57 public class AverageDeviationCalculator : ConsumptionNormCalculator
58 {
59     protected override decimal CalculateDeviation(IEnumerable<Consumption> consumptionData, decimal baseline)
60     {
61         var consumptions = consumptionData.Select(c => c.ConsumedAmount).ToList();
62         var sumOfDeviations = consumptions.Sum(c => Math.Abs(c - baseline));
63         return sumOfDeviations / consumptions.Count;
64     }
65 
66     public override bool IsAnomaly(decimal currentConsumption, decimal baselineConsumption, decimal deviation)
67     {
68         return Math.Abs(currentConsumption - baselineConsumption) > 3 * deviation;
69     }
70 }
71 
72 public class StandardDeviationCalculator : ConsumptionNormCalculator
73 {
74     protected override decimal CalculateDeviation(IEnumerable<Consumption> consumptionData, decimal baseline)
75     {
76         var consumptions = consumptionData.Select(c => c.ConsumedAmount).ToList();
77         var sumOfSquares = consumptions.Sum(c => (c - baseline) * (c - baseline));
78         var variance = sumOfSquares / (consumptions.Count - 1);
79         return (decimal)Math.Sqrt((double)variance);
80     }
81 
82     public override bool IsAnomaly(decimal currentConsumption, decimal baselineConsumption, decimal deviation)
83     {
84         return Math.Abs(currentConsumption - baselineConsumption) > 2 * deviation;
85     }
86 }


Б.4 Програмний код патерну «Компонувальник» для розрахунку сумарної вартості споживання за період


1 /// <summary>
2 /// Represents a component for calculating the cost of resource consumption.
3 /// </summary>
4 public interface IConsumptionComponent
5 {
6     /// <summary>
7     /// Calculates the cost of resource consumption.
8     /// </summary>
9     /// <returns>The calculated cost.</returns>
10     decimal CalculateCost();
11 }
12 
13 public class DayConsumption : IConsumptionComponent
14 {
15     public DateTime Date { get; set; }
16     public ResourceType ResourceType { get; set; }
17     public decimal ConsumedAmount { get; set; }
18     public Tariff Tariff { get; set; }
19 
20     public decimal CalculateCost()
21     {
22         return ConsumedAmount * Tariff.PricePerUnit;
23     }
24 }
25 
26 public class PeriodConsumption : IConsumptionComponent
27 {
28     private readonly List<DayConsumption> _dayConsumptions = new List<DayConsumption>();
29 
30     public void AddDayConsumption(DayConsumption dayConsumption)
31     {
32         _dayConsumptions.Add(dayConsumption);
33     }
34 
35     public decimal CalculateCost()
36     {
37         return _dayConsumptions.Sum(d => d.CalculateCost());
38     }
39 }


Б.5 Програмний код файлу sketch.ino


1 /**
2  * @file sketch.ino
3  * @brief Main file for the IoT resource consumption monitoring system.
4  */
5 
6 #include <Arduino.h>
7 #include "config.h"
8 #include "data_collection_service.h"
9 #include "analytics_service.h"
10 #include "notification_service.h"
11 #include "tariff_repository.h"
12 #include "consumption_repository.h"
13 #include "user_singleton.h"
14 #include "sensor_service.h"
15 #include "authentication_service.h"
16 #include "utils.h"
17 
18 float waterConsumption = 0;      ///< Water consumption value
19 float gasConsumption = 0;        ///< Gas consumption value
20 float electricityConsumption = 0;  ///< Electricity consumption value
21 
22 unsigned long lastSensorReadTime = 0;  ///< Timestamp of the last sensor read
23 unsigned long lastDataSendTime = 0;    ///< Timestamp of the last data send
24 unsigned long lastStatsTime = 0;       ///< Timestamp of the last stats calculation
25 
26 std::vector<float> waterStatsConsumptions;        ///< Vector of water consumption values for statistics
27 std::vector<float> gasStatsConsumptions;          ///< Vector of gas consumption values for statistics
28 std::vector<float> electricityStatsConsumptions;  ///< Vector of electricity consumption values for statistics
29 
30 const int CS_PIN = 5; ///< SD card pin connection
31 
32 /**
33  * @brief Setup function for the Arduino sketch.
34  */
35 void setup() {
36   Serial.begin(115200);
37 
38   if (!SD.begin(CS_PIN)) {
39     Serial.println("Card initialization failed!");
40     while (true);
41   }
42   Serial.println("initialization done.");
43 
44   Config& config = ConfigSingleton::getInstance();
45 
46   pinMode(config.ldrWaterPin, INPUT);
47   pinMode(config.ldrGasPin, INPUT);
48   pinMode(config.ldrElectricityPin, INPUT);
49 
50   WiFi.begin(config.ssid.c_str(), config.password.c_str());
51   while (WiFi.status() != WL_CONNECTED) {
52     delay(1000);
53     Serial.println("Connecting to WiFi...");
54   }
55   Serial.println("Connected to WiFi");
56 
57   configTime(0, 0, "pool.ntp.org");
58   while (!time(nullptr)) {
59     Serial.print(".");
60     delay(1000);
61   }
62   Serial.println("\nTime synchronized");
63 
64   if (authenticateUser()) {
65     Serial.println("User authenticated");
66   } else {
67     Serial.println("User authentication failed");
68   }
69 }
70 
71 /**
72  * @brief Main loop function for the Arduino sketch.
73  */
74 void loop() {
75   Config& config = ConfigSingleton::getInstance();
76 
77   DataCollectionService dataCollectionService;
78   AnalyticsService analyticsService;
79   NotificationService notificationService;
80 
81   TariffRepository tariffRepository;
82   ConsumptionRepository consumptionRepository;
83 
84   unsigned long currentTime = millis();
85 
86   if (currentTime - lastSensorReadTime >= config.sensorReadInterval) {
87     lastSensorReadTime = currentTime;
88 
89     float waterValue = readLux(config.ldrWaterPin);
90     float gasValue = readLux(config.ldrGasPin);
91     float electricityValue = readLux(config.ldrElectricityPin);
92 
93     Serial.println("--------------------------------------------------");
94     Serial.println("Sensor values read:");
95     Serial.print("Water: ");
96     Serial.println(waterValue);
97     Serial.print("Gas: ");
98     Serial.println(gasValue);
99     Serial.print("Electricity: ");
100     Serial.println(electricityValue);
101     Serial.println("--------------------------------------------------");
102 
103     dataCollectionService.sendSensorDataToServer(waterValue, config.waterIotDeviceId);
104     dataCollectionService.sendSensorDataToServer(gasValue, config.gasIotDeviceId);
105     dataCollectionService.sendSensorDataToServer(electricityValue, config.electricityIotDeviceId);
106 
107     notificationService.checkSensorValuesAndSendNotifications(waterValue, gasValue, electricityValue);
108 
109     waterConsumption += waterValue;
110     gasConsumption += gasValue;
111     electricityConsumption += electricityValue;
112 
113     waterStatsConsumptions.emplace_back(waterValue);
114     gasStatsConsumptions.emplace_back(gasValue);
115     electricityStatsConsumptions.emplace_back(electricityValue);
116   }
117 
118   if (currentTime - lastDataSendTime >= config.dataSendInterval) {
119     lastDataSendTime = currentTime;
120 
121     float convertedWaterConsumption = consumptionRepository.convertConsumptionUnit(waterConsumption, config.waterTariffId, ResourceType::Water, config.waterInitialUnit);
122     float convertedGasConsumption = consumptionRepository.convertConsumptionUnit(gasConsumption, config.gasTariffId, ResourceType::Gas, config.gasInitialUnit);
123     float convertedElectricityConsumption = consumptionRepository.convertConsumptionUnit(electricityConsumption, config.electricityTariffId, ResourceType::Electricity, config.electricityInitialUnit);
124 
125     Serial.println("--------------------------------------------------");
126     Serial.println("Sending consumption data to server:");
127     Serial.print("Water: ");
128     Serial.println(convertedWaterConsumption);
129     Serial.print("Gas: ");
130     Serial.println(convertedGasConsumption);
131     Serial.print("Electricity: ");
132     Serial.println(convertedElectricityConsumption);
133     Serial.println("--------------------------------------------------");
134 
135     dataCollectionService.sendConsumptionToServer(convertedWaterConsumption, config.waterTariffId);
136     dataCollectionService.sendConsumptionToServer(convertedGasConsumption, config.gasTariffId);
137     dataCollectionService.sendConsumptionToServer(convertedElectricityConsumption, config.electricityTariffId);
138 
139     waterConsumption = 0;
140     gasConsumption = 0;
141     electricityConsumption = 0;
142   }
143 
144   if (currentTime - lastStatsTime >= config.statsInterval) {
145     lastStatsTime = currentTime;
146 
147     ConsumptionStats waterStats = analyticsService.calculateConsumptionStats(waterStatsConsumptions);
148     ConsumptionStats gasStats = analyticsService.calculateConsumptionStats(gasStatsConsumptions);
149     ConsumptionStats electricityStats = analyticsService.calculateConsumptionStats(electricityStatsConsumptions);
150 
151     String waterStatsMessage = analyticsService.formatStatsMessage(waterStats, "Water");
152     String gasStatsMessage = analyticsService.formatStatsMessage(gasStats, "Gas");
153     String electricityStatsMessage = analyticsService.formatStatsMessage(electricityStats, "Electricity");
154 
155     notificationService.sendStatsToServer(waterStatsMessage, config.waterIotDeviceId);
156     notificationService.sendStatsToServer(gasStatsMessage, config.gasIotDeviceId);
157     notificationService.sendStatsToServer(electricityStatsMessage, config.electricityIotDeviceId);
158 
159     waterStatsConsumptions.clear();
160     gasStatsConsumptions.clear();
161     electricityStatsConsumptions.clear();
162   }
163 }


Б.6 Програмний код файлу tariff_repository.h


1 /**
2  * @file tariff_repository.h
3  * @brief Tariff repository header file for the IoT resource consumption monitoring system.
4  */
5 
6 #ifndef TARIFF_REPOSITORY_H
7 #define TARIFF_REPOSITORY_H
8 
9 #include <Arduino.h>
10 #include <HTTPClient.h>
11 #include <ArduinoJson.h>
12 #include "config.h"
13 
14 /**
15  * @brief Repository class for accessing tariff data from the server.
16  */
17 class TariffRepository {
18 public:
19   /**
20    * @brief Get the resource type ID from the tariff ID.
21    * @param tariffId The tariff ID.
22    * @return The resource type ID.
23    */
24   static int getResourceTypeIdFromTariff(int tariffId);
25 };
26 
27 #endif // TARIFF_REPOSITORY_H


Б.7 Програмний код файлу consumption_repository.cpp


1 /**
2  * @file consumption_repository.cpp
3  * @brief Consumption repository implementation file for the IoT resource consumption monitoring system.
4  */
5 
6 #include "consumption_repository.h"
7 
8 /**
9  * @brief Get the unit from the server based on the resource type ID.
10  * @param id The resource type ID.
11  * @return The unit string.
12  */
13 String ConsumptionRepository::getUnitFromServer(int id) {
14   if (WiFi.status() == WL_CONNECTED) {
15     HTTPClient http;
16     http.begin(ConfigSingleton::getInstance().serverUrl + "api/ResourceType/" + String(id));
17     http.addHeader("Content-Type", "application/json");
18     http.addHeader("ngrok-skip-browser-warning", "true");
19     int httpResponseCode = http.GET();
20 
21     if (httpResponseCode == 200) {
22       String response = http.getString();
23       DynamicJsonDocument doc(1024);
24       DeserializationError error = deserializeJson(doc, response);
25 
26      if (error) {
27        Serial.print(F("deserializeJson() failed: "));
28        Serial.println(error.c_str());
29        return "";
30      }
31 
32      return doc["unit"].as<String>();
33    }
34 
35    http.end();
36  }
37  return "";
38 }
39 
40 /**
41 * @brief Convert the consumption unit based on the tariff ID and initial unit.
42 * @param consumption The consumption value.
43 * @param tariffId The tariff ID.
44 * @param resourceType The resource type.
45 * @param initialUnit The initial unit.
46 * @return The converted consumption value.
47 */
48 float ConsumptionRepository::convertConsumptionUnit(float consumption, int tariffId, ResourceType resourceType, const String& initialUnit) {
49  if (WiFi.status() == WL_CONNECTED) {
50    int resourceTypeId = TariffRepository::getResourceTypeIdFromTariff(tariffId);
51 
52    if (resourceTypeId != -1) {
53      String unit = getUnitFromServer(resourceTypeId);
54 
55      if (unit != "") {
56        float convertedConsumption = convertUnit(consumption, initialUnit, unit);
57        return convertedConsumption;
58      }
59    }
60  }
61 
62  return consumption;
63 }
64 
65 /**
66 * @brief Convert the value from one unit to another.
67 * @param value The value to convert.
68 * @param fromUnit The source unit.
69 * @param toUnit The target unit.
70 * @return The converted value.
71 */
72 float ConsumptionRepository::convertUnit(float value, String fromUnit, String toUnit) {
73  if (fromUnit == toUnit) {
74    return value;
75  }
76 
77  if (fromUnit == "mВі" && toUnit == "l") {
78    return value * 1000;
79  } else if (fromUnit == "mВі" && toUnit == "gal") {
80    return value * 264.172;
81  } else if (fromUnit == "l" && toUnit == "mВі") {
82    return value / 1000;
83  } else if (fromUnit == "l" && toUnit == "gal") {
84    return value * 0.264172;
85  } else if (fromUnit == "gal" && toUnit == "mВі") {
86    return value / 264.172;
87  } else if (fromUnit == "gal" && toUnit == "l") {
88    return value / 0.264172;
89  }
90 
91  if (fromUnit == "mВі" && toUnit == "ftВі") {
92    return value * 35.3147;
93  } else if (fromUnit == "ftВі" && toUnit == "mВі") {
94    return value / 35.3147;
95  }
96 
97  if (fromUnit == "kWh" && toUnit == "MWh") {
98    return value / 1000;
99  } else if (fromUnit == "kWh" && toUnit == "J") {
100    return value * 3.6e+6;
101  } else if (fromUnit == "MWh" && toUnit == "kWh") {
102    return value * 1000;
103  } else if (fromUnit == "MWh" && toUnit == "J") {
104    return value * 3.6e+9;
105  } else if (fromUnit == "J" && toUnit == "kWh") {
106    return value / 3.6e+6;
107  } else if (fromUnit == "J" && toUnit == "MWh") {
108    return value / 3.6e+9;
109  }
110 
111  return value;
112 }


Б.8 Програмний код файлу config.h


1 /**
2  * @file config.h
3  * @brief Configuration header file for the IoT resource consumption monitoring system.
4  */
5 
6 #ifndef CONFIG_H
7 #define CONFIG_H
8 
9 #include <Arduino.h>
10 #include <ArduinoJson.h>
11 #include <SD.h>
12 
13 /**
14  * @brief Structure representing the configuration.
15  */
16 struct Config {
17   int ldrWaterPin;           ///< LDR water pin
18   int ldrGasPin;             ///< LDR gas pin
19   int ldrElectricityPin;     ///< LDR electricity pin
20   float gamma;               ///< Gamma value for LDR calibration
21   float rl10;                ///< RL10 value for LDR calibration
22   String ssid;               ///< Wi-Fi SSID
23   String password;           ///< Wi-Fi password
24   String serverUrl;          ///< Server URL
25   String userLogin;          ///< User login
26   String userPassword;       ///< User password
27   int waterIotDeviceId;      ///< Water IoT device ID
28   int gasIotDeviceId;        ///< Gas IoT device ID
29   int electricityIotDeviceId;  ///< Electricity IoT device ID
30   int waterTariffId;         ///< Water tariff ID
31   int gasTariffId;           ///< Gas tariff ID
32   int electricityTariffId;   ///< Electricity tariff ID
33   String waterInitialUnit;   ///< Water initial unit
34   String gasInitialUnit;     ///< Gas initial unit
35   String electricityInitialUnit;  ///< Electricity initial unit
36   unsigned long sensorReadInterval;  ///< Sensor read interval
37   unsigned long dataSendInterval;    ///< Data send interval
38   unsigned long statsInterval;       ///< Stats calculation interval
39 };
40 
41 /**
42  * @brief Singleton class for managing the configuration.
43  */
44 class ConfigSingleton {
45 public:
46   /**
47    * @brief Get the configuration instance.
48    * @return Reference to the configuration instance.
49    */
50   static Config& getInstance() {
51     static ConfigSingleton instance;
52     return instance.config;
53   }
54 
55 private:
56   ConfigSingleton() { loadConfig(); }
57 
58   void loadConfig() {
59     File configFile = SD.open("/config.json");
60     if (configFile) {
61       DynamicJsonDocument doc(1024);
62       DeserializationError error = deserializeJson(doc, configFile);
63       if (error) {
64         Serial.println("Failed to parse config file");
65         return;
66       }
67       config.ldrWaterPin = doc["LDR_WATER_PIN"].as<int>();
68       config.ldrGasPin = doc["LDR_GAS_PIN"].as<int>();
69       config.ldrElectricityPin = doc["LDR_ELECTRICITY_PIN"].as<int>();
70       config.gamma = doc["GAMMA"].as<float>();
71       config.rl10 = doc["RL10"].as<float>();
72       config.ssid = doc["SSID"].as<String>();
73       config.password = doc["PASSWORD"].as<String>();
74       config.serverUrl = doc["SERVER_URL"].as<String>();
75       config.userLogin = doc["USER_LOGIN"].as<String>();
76       config.userPassword = doc["USER_PASSWORD"].as<String>();
77       config.waterIotDeviceId = doc["WATER_IOT_DEVICE_ID"].as<int>();
78       config.gasIotDeviceId = doc["GAS_IOT_DEVICE_ID"].as<int>();
79       config.electricityIotDeviceId = doc["ELECTRICITY_IOT_DEVICE_ID"].as<int>();
80       config.waterTariffId = doc["WATER_TARIFF_ID"].as<int>();
81       config.gasTariffId = doc["GAS_TARIFF_ID"].as<int>();
82       config.electricityTariffId = doc["ELECTRICITY_TARIFF_ID"].as<int>();
83       config.waterInitialUnit = doc["WATER_INITIAL_UNIT"].as<String>();
84       config.gasInitialUnit = doc["GAS_INITIAL_UNIT"].as<String>();
85       config.electricityInitialUnit = doc["ELECTRICITY_INITIAL_UNIT"].as<String>();
86       config.sensorReadInterval = doc["SENSOR_READ_INTERVAL"].as<unsigned long>();
87       config.dataSendInterval = doc["DATA_SEND_INTERVAL"].as<unsigned long>();
88       config.statsInterval = doc["STATS_INTERVAL"].as<unsigned long>();
89       configFile.close();
90       Serial.println("Configuration loaded");
91     } else {
92       Serial.println("Failed to open config file");
93     }
94   }
95 
96   Config config;  ///< Configuration instance
97 };
98 
99 #endif // CONFIG_H


Б.9 Програмний код файлу user_singleton.h


1 /**
2  * @file user_singleton.h
3  * @brief User singleton header file for the IoT resource consumption monitoring system.
4  */
5 
6 #ifndef USER_SINGLETON_H
7 #define USER_SINGLETON_H
8 
9 #include <Arduino.h>
10 #include <ArduinoJson.h>
11 
12 /**
13  * @brief Structure representing a user.
14  */
15 struct User {
16   int id;           ///< User ID
17   String login;     ///< User login
18   String phone;     ///< User phone number
19   String email;     ///< User email
20   String lastName;  ///< User last name
21   String firstName;   ///< User first name
22   String middleName;  ///< User middle name
23   String role;        ///< User role
24 };
25 
26 /**
27  * @brief Singleton class for managing the user instance.
28  */
29 class UserSingleton {
30 public:
31   /**
32    * @brief Get the user instance.
33    * @return Reference to the user instance.
34    */
35   static User& getInstance() {
36     static UserSingleton instance;
37     return instance.user;
38   }
39 
40   /**
41    * @brief Set the user data from a JSON object.
42    * @param userData The JSON object containing user data.
43    */
44   static void setUserData(const JsonObject& userData) {
45     User& instance = getInstance();
46     instance.id = userData["id"].as<int>();
47     instance.login = userData["login"].as<String>();
48     instance.phone = userData["phone"].as<String>();
49     instance.email = userData["email"].as<String>();
50     instance.lastName = userData["lastName"].as<String>();
51     instance.firstName = userData["firstName"].as<String>();
52     instance.middleName = userData["middleName"].as<String>();
53     instance.role = userData["role"].as<String>();
54   }
55 
56 private:
57   UserSingleton() {}  ///< Private constructor to prevent instantiation
58 
59   User user;  ///< User instance
60 };
61 
62 #endif // USER_SINGLETON_H


Б.10 Програмний код файлу data_collection_service.cpp


1 /**
2  * @file data_collection_service.cpp
3  * @brief Data collection service implementation file for the IoT resource consumption monitoring system.
4  */
5 
6 #include "data_collection_service.h"
7 #include "utils.h"
8 
9 
10 /**
11  * @brief Send sensor data to the server.
12  * @param value The sensor value.
13  * @param deviceId The IoT device ID.
14  */
15 void DataCollectionService::sendSensorDataToServer(float value, int deviceId) {
16   if (WiFi.status() == WL_CONNECTED) {
17     HTTPClient http;
18     http.begin(ConfigSingleton::getInstance().serverUrl + "api/SensorData");
19     http.addHeader("Content-Type", "application/json");
20     http.addHeader("ngrok-skip-browser-warning", "true");
21     DynamicJsonDocument doc(1024);
22     doc["iotDeviceId"] = deviceId;
23     doc["timestamp"] = getFormattedUtcTime();
24     doc["value"] = value;
25 
26     String payload;
27     serializeJson(doc, payload);
28 
29    Serial.println("Sending sensor data to server:");
30    Serial.println(payload);
31 
32    int httpResponseCode = http.POST(payload);
33    String response = http.getString();
34 
35    Serial.print("Sensor data sent to server. Response code: ");
36    Serial.println(httpResponseCode);
37    Serial.println("Response: " + response);
38 
39    http.end();
40  }
41 }
42 
43 /**
44 * @brief Send consumption data to the server.
45 * @param consumption The consumption value.
46 * @param tariffId The tariff ID.
47 */
48 void DataCollectionService::sendConsumptionToServer(float consumption, int tariffId) {
49  if (WiFi.status() == WL_CONNECTED) {
50    HTTPClient http;
51    http.begin(ConfigSingleton::getInstance().serverUrl + "api/Consumption");
52    http.addHeader("Content-Type", "application/json");
53    http.addHeader("ngrok-skip-browser-warning", "true");
54    DynamicJsonDocument doc(1024);
55    doc["userId"] = UserSingleton::getInstance().id;
56    doc["tariffId"] = tariffId;
57    doc["date"] = getFormattedUtcTime();
58    doc["consumedAmount"] = consumption;
59 
60    String payload;
61    serializeJson(doc, payload);
62 
63    Serial.println("Sending consumption data to server:");
64    Serial.println(payload);
65 
66    int httpResponseCode = http.POST(payload);
67    String response = http.getString();
68 
69    Serial.print("Consumption sent to server. Response code: ");
70    Serial.println(httpResponseCode);
71    Serial.println("Response: " + response);
72 
73    http.end();
74  }
75 }


Б.11 Програмний код файлу notification_service.cpp


1 /**
2  * @file notification_service.cpp
3  * @brief Notification service implementation file for the IoT resource consumption monitoring system.
4  */
5 
6 #include "notification_service.h"
7 #include "utils.h"
8 
9 /**
10  * @brief Send a notification to the server.
11  * @param userId The user ID.
12  * @param iotDeviceId The IoT device ID.
13  * @param notificationType The notification type.
14  * @param text The notification text.
15  */
16 void NotificationService::sendNotificationToServer(int userId, int iotDeviceId, NotificationType notificationType, const String& text) {
17   if (WiFi.status() == WL_CONNECTED) {
18     HTTPClient http;
19     http.begin(ConfigSingleton::getInstance().serverUrl + "api/Notification");
20     http.addHeader("Content-Type", "application/json");
21     http.addHeader("ngrok-skip-browser-warning", "true");
22     DynamicJsonDocument doc(1024);
23     doc["userId"] = userId;
24     doc["iotDeviceId"] = iotDeviceId;
25     doc["notificationType"] = static_cast<int>(notificationType);
26     doc["createdAt"] = getFormattedUtcTime();
27     doc["text"] = text;
28 
29     String payload;
30     serializeJson(doc, payload);
31 
32     Serial.println("Sending notification to server:");
33     Serial.println(payload);
34 
35     int httpResponseCode = http.POST(payload);
36     String response = http.getString();
37 
38     Serial.print("Notification sent to server. Response code: ");
39     Serial.println(httpResponseCode);
40     Serial.println("Response: " + response);
41 
42     http.end();
43   }
44 }
45 
46 /**
47  * @brief Send consumption statistics to the server.
48  * @param statsText The statistics text.
49  * @param deviceId The IoT device ID.
50  */
51 void NotificationService::sendStatsToServer(const String& statsText, int deviceId) {
52   if (WiFi.status() == WL_CONNECTED) {
53     HTTPClient http;
54     http.begin(ConfigSingleton::getInstance().serverUrl + "api/Notification");
55     http.addHeader("Content-Type", "application/json");
56     http.addHeader("ngrok-skip-browser-warning", "true");
57     DynamicJsonDocument doc(1024);
58     doc["userId"] = UserSingleton::getInstance().id;
59     doc["iotDeviceId"] = deviceId;
60     doc["notificationType"] = static_cast<int>(NotificationType::Normal);
61     doc["createdAt"] = getFormattedUtcTime();
62     doc["text"] = statsText;
63 
64     String payload;
65     serializeJson(doc, payload);
66 
67     Serial.println("Sending stats to server:");
68     Serial.println(payload);
69 
70     int httpResponseCode = http.POST(payload);
71     String response = http.getString();
72 
73     Serial.print("Stats sent to server. Response code: ");
74     Serial.println(httpResponseCode);
75     Serial.println("Response: " + response);
76 
77     http.end();
78   }
79 }
80 
81 /**
82  * @brief Check sensor values and send notifications based on thresholds.
83  * @param waterValue The water sensor value.
84  * @param gasValue The gas sensor value.
85  * @param electricityValue The electricity sensor value.
86  */
87 void NotificationService::checkSensorValuesAndSendNotifications(float waterValue, float gasValue, float electricityValue) {
88   if (waterValue > 1000) {
89     sendNotificationToServer(UserSingleton::getInstance().id, ConfigSingleton::getInstance().waterIotDeviceId, NotificationType::Critical, "Water consumption is critically high!");
90   } else if (waterValue > 500) {
91     sendNotificationToServer(UserSingleton::getInstance().id, ConfigSingleton::getInstance().waterIotDeviceId, NotificationType::Warning, "Water consumption is high. Please check.");
92   }
93 
94   if (gasValue > 1000) {
95     sendNotificationToServer(UserSingleton::getInstance().id, ConfigSingleton::getInstance().gasIotDeviceId, NotificationType::Critical, "Gas consumption is critically high!");
96   } else if (gasValue > 500) {
97     sendNotificationToServer(UserSingleton::getInstance().id, ConfigSingleton::getInstance().gasIotDeviceId, NotificationType::Warning, "Gas consumption is high. Please check.");
98   }
99 
100   if (electricityValue > 1000) {
101     sendNotificationToServer(UserSingleton::getInstance().id, ConfigSingleton::getInstance().electricityIotDeviceId, NotificationType::Critical, "Electricity consumption is critically high!");
102   } else if (electricityValue > 500) {
103     sendNotificationToServer(UserSingleton::getInstance().id, ConfigSingleton::getInstance().electricityIotDeviceId, NotificationType::Warning, "Electricity consumption is high. Please check.");
104   }
105 }

Б.12 Програмний код файлу analytics_service.cpp


1 /**
2  * @file analytics_service.cpp
3  * @brief Analytics service implementation file for the IoT resource consumption monitoring system.
4  */
5 
6 #include "analytics_service.h"
7 
8 /**
9  * @brief Calculate consumption statistics.
10  * @param consumption The vector of consumption values.
11  * @return The calculated consumption statistics.
12  */
13 ConsumptionStats AnalyticsService::calculateConsumptionStats(const std::vector<float>& consumption) {
14   float sum = 0;
15   float min = consumption.empty() ? 0 : consumption[0];
16   float max = consumption.empty() ? 0 : consumption[0];
17 
18   for (float value : consumption) {
19     sum += value;
20     if (value < min) {
21       min = value;
22     }
23     if (value > max) {
24       max = value;
25     }
26   }
27 
28   float average = consumption.empty() ? 0 : sum / consumption.size();
29 
30   float sumSquaredDiff = 0;
31   for (float value : consumption) {
32     float diff = value - average;
33     sumSquaredDiff += diff * diff;
34   }
35 
36   float variance = consumption.size() <= 1 ? 0 : sumSquaredDiff / (consumption.size() - 1);
37   float stdDev = sqrt(variance);
38 
39   ConsumptionStats stats = { average, min, max, stdDev };
40   return stats;
41 }
42 
43 /**
44  * @brief Format the consumption statistics as a message string.
45  * @param stats The consumption statistics.
46  * @param resourceName The name of the resource.
47  * @return The formatted statistics message.
48  */
49 String AnalyticsService::formatStatsMessage(const ConsumptionStats& stats, const String& resourceName) {
50   String message = resourceName + " Consumption Stats:\n";
51   message += "Average: " + String(stats.average) + "\n";
52   message += "Min: " + String(stats.min) + "\n";
53   message += "Max: " + String(stats.max) + "\n";
54   message += "Standard Deviation: " + String(stats.stdDev) + "\n";
55   return message;
56 }


Б.13 Програмний код файлу Header.js


1 // src/components/Header.js
2 import React from 'react';
3 import { Link } from 'react-router-dom';
4 import '../styles/header.css';
5 import accountIcon from '../assets/account-icon.png';
6 import LanguageSelector from './LanguageSelector';
7 import { FormattedMessage } from 'react-intl';
8 
9 const Header = ({ title, navigationItems }) => {
10     return (
11         <header className="header">
12             <nav className="navbar navbar-expand-lg navbar-light">
13                 <div className="container">
14                     <Link className="navbar-brand logo" to="/">
15                         {title}
16                     </Link>
17                     <button className="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
18                         <span className="navbar-toggler-icon"></span>
19                     </button>
20                     <div className="collapse navbar-collapse" id="navbarNav">
21                         <ul className="navbar-nav mx-auto">
22                             {navigationItems.map((item) => (
23                                 <li key={item.id} className="nav-item">
24                                     <Link className="nav-link" to={item.path}>
25                                         <FormattedMessage id={item.labelId} defaultMessage={item.defaultLabel} />
26                                     </Link>
27                                 </li>
28                             ))}
29                         </ul>
30                         <div className="navbar-nav">
31                             <LanguageSelector />
32                             <Link to="/admin/account" className="btn btn-link account-btn">
33                                 <img src={accountIcon} alt="Account" />
34                             </Link>
35                         </div>
36                     </div>
37                 </div>
38             </nav>
39         </header>
40     );
41 };
42 
43 export default Header;


Б.14 Програмний код файлу AuthService.js


1 // src/services/AuthService.js
2 import apiInstance from './ApiService';
3 
4 export const register = async (userData) => {
5     try {
6         const response = await apiInstance.post('/api/User', userData);
7         return response.data;
8     } catch (error) {
9         throw error.response.data;
10     }
11 };
12 
13 export const login = async (credentials) => {
14     try {
15         const response = await apiInstance.post('/api/User/authenticate', credentials);
16         return response.data;
17     } catch (error) {
18         throw error.response.data;
19     }
20 };
21 
22 export const logout = async () => {
23     try {
24         const response = await apiInstance.post('/api/User/logout');
25         return response.data;
26     } catch (error) {
27         throw error.response.data;
28     }
29 };


Б.15 Програмний код файлу en.json


1 {
2   "app.title": "Ecomechan",
3   "app.home": "Home",
4   "app.about": "About",
5   "app.services": "Services",
6   "app.contacts": "Contacts",
7   "app.login": "Login",
8   "app.register": "Register",
9   "app.description": "Smart distribution of electricity, gas, and water resources.",
10   "footer.links": "Links",
11   "footer.about": "About Us",
12   "footer.contacts": "Contacts",
13   "footer.privacyPolicy": "Privacy Policy",
14   "footer.termsOfUse": "Terms of Use",
15   "footer.address": "Address: 14 Nauki Ave, Kharkiv, Kharkiv Oblast, 61166",
16   "footer.phone": "Phone: {phoneNumber}",
17   "footer.email": "Email: {email}",
18   "footer.copyright": "{copyright} 2023 Ecomechan. All rights reserved.",
19   "home.welcome": "Welcome to Ecomechan",
20   "home.description": "Smart distribution of electricity, gas, and water resources.",
21   "about.title": "About Us",
22   "about.description1": "EcoMeChan is an innovative software system designed for efficient management and optimization of utility resource consumption, such as water, electricity, and gas. Our mission is to promote sustainable development and reduce the negative impact on the environment through smart resource allocation.",
23   "about.description2": "We strive to help cities, businesses, and individual users reduce utility costs, increase resource efficiency, and ensure reliable supply. Utilizing advanced technologies and intelligent data analysis, EcoMeChan provides powerful tools for real-time monitoring, control, and optimization of resource consumption.",
24   "about.description3": "Our team consists of experienced professionals in the field of software development, energy, and resource management. We are dedicated to creating environmentally responsible solutions that help our clients achieve their goals in sustainable development and resource efficiency.",
25   "services.title": "Our Services",
26   "services.service1": "Service 1",
27   "services.service2": "Service 2",
28   "services.service3": "Service 3",
29   "contacts.title": "Contacts",
30   "contacts.address": "Address: 14 Nauki Ave, Kharkiv, Kharkiv Oblast, 61166",
31   "contacts.phone": "Phone: {phoneNumber}",
32   "contacts.email": "Email: {email}",
33   "login.title": "Login",
34   "login.email": "Email",
35   "login.password": "Password",
36   "login.submit": "Login",
37   "login.invalidCredentials": "Invalid email or password",
38   "registration.title": "Registration",
39   "registration.email": "Email",
40   "registration.password": "Password",
41   "registration.submit": "Register",
42   "registration.invalidCredentials": "Invalid email or password",
43   "adminFooter.title": "Admin Dashboard",
44   "adminFooter.copyright": "{copyright} 2023 Admin Dashboard. All rights reserved.",
45   "adminHeader.title": "Admin Dashboard",
46   "adminHeader.home": "Home",
47   "managerFooter.title": "Manager Dashboard",
48   "managerFooter.copyright": "{copyright} 2023 Manager Dashboard. All rights reserved.",
49   "managerHeader.title": "Manager Dashboard",
50   "managerHeader.home": "Home",
51   "userFooter.title": "User Dashboard",
52   "userFooter.copyright": "{copyright} 2023 User Dashboard. All rights reserved.",
53   "userHeader.title": "User Dashboard",
54   "userHeader.home": "Home",
55   "userHeader.personalAccount": "Personal Account",
56   "userHeader.consumptionHistory": "Consumption History",
57   "userHeader.iotDevices": "IoT Devices",
58   "userHeader.explore": "Explore",
59   "managerHeader.userProfile": "User Profile",
60   "managerHeader.consumptionHistory": "Consumption History",
61   "managerHeader.iotEvents": "IoT Events",
62   "adminHeader.accountManagement": "Account Management",
63   "adminHeader.iotDeviceManagement": "IoT Device Management",
64   "adminHeader.monitoring": "Monitoring",
65   "adminAccountPage.title": "Admin Account",
66   "adminAccountPage.login": "Login",
67   "adminAccountPage.email": "Email:",
68   "adminAccountPage.firstName": "First Name:",
69   "adminAccountPage.lastName": "Last Name:",
70   "adminAccountPage.middleName": "Middle Name:",
71   "adminAccountPage.phoneNumber": "Phone Number:",
72   "adminHomePage.welcome": "Welcome, Admin!",
73   "managerAccountPage.title": "Manager Account",
74   "managerAccountPage.login": "Login",
75   "managerAccountPage.email": "Email:",
76   "managerAccountPage.firstName": "First Name:",
77   "managerAccountPage.lastName": "Last Name:",
78   "managerAccountPage.middleName": "Middle Name:",
79   "managerAccountPage.phoneNumber": "Phone Number:",
80   "managerHomePage.welcome": "Welcome, Manager!",
81   "userAccountPage.title": "User Account",
82   "userAccountPage.login": "Login",
83   "userAccountPage.email": "Email:",
84   "userAccountPage.firstName": "First Name:",
85   "userAccountPage.lastName": "Last Name:",
86   "userAccountPage.middleName": "Middle Name:",
87   "userAccountPage.phoneNumber": "Phone Number:",
88   "userHomePage.welcome": "Welcome, User!",
89   "accountPage.logout": "Logout",
90   "userPersonalAccountPage.title": "Personal Account",
91   "userConsumptionHistoryPage.title": "Consumption History",
92   "userIoTDevicesPage.title": "IoT Devices",
93   "userExplorePage.title": "Explore",
94   "managerUserProfilePage.title": "User Profile",
95   "managerConsumptionHistoryPage.title": "Consumption History",
96   "managerIoTEventsPage.title": "IoT Events",
97   "adminAccountManagementPage.title": "Account Management",
98   "adminIoTDeviceManagementPage.title": "IoT Device Management",
99   "unit.water": "liters",
100   "unit.gas": "mВі",
101   "unit.electricity": "kWh",
102   "currency.usd": "USD",
103   "currency.eur": "EUR",
104   "currency.uah": "UAH",
105   "resourceType.water": "Water",
106   "resourceType.gas": "Gas",
107   "resourceType.electricity": "Electricity",
108   "userConsumptionHistoryPage.date": "Date",
109   "userConsumptionHistoryPage.resourceType": "Resource Type",
110   "userConsumptionHistoryPage.amount": "Amount",
111   "userConsumptionHistoryPage.cost": "Cost",
112   "userConsumptionHistoryPage.time": "Time",
113   "device.status.active": "Active",
114   "device.status.inactive": "Inactive",
115   "device.status.unknown": "Unknown",
116   "device.type.waterSensor": "Water Sensor",
117   "device.type.gasSensor": "Gas Sensor",
118   "device.type.electricitySensor": "Electricity Sensor",
119   "device.type.unknown": "Unknown",
120   "userIoTDevicesPage.deviceType": "Type: {deviceType}",
121   "userIoTDevicesPage.deviceStatus": "Status: {deviceStatus}",
122   "adminAccountManagementPage.login": "Login",
123   "adminAccountManagementPage.firstName": "First Name",
124   "adminAccountManagementPage.lastName": "Last Name",
125   "adminAccountManagementPage.middleName": "Middle Name",
126   "adminAccountManagementPage.email": "Email",
127   "adminAccountManagementPage.role": "Role",
128   "adminAccountManagementPage.actions": "Actions",
129   "adminAccountManagementPage.edit": "Edit",
130   "adminAccountManagementPage.delete": "Delete",
131   "role.user": "User",
132   "role.admin": "Admin",
133   "role.municipalResourceManager": "Municipal Resource Manager",
134   "role.unknown": "Unknown",
135   "adminIoTDeviceManagementPage.name": "Name",
136   "adminIoTDeviceManagementPage.type": "Type",
137   "adminIoTDeviceManagementPage.status": "Status",
138   "adminIoTDeviceManagementPage.edit": "Edit",
139   "adminIoTDeviceManagementPage.delete": "Delete",
140   "adminIoTDeviceManagementPage.save": "Save",
141   "adminIoTDeviceManagementPage.cancel": "Cancel",
142   "notification.type.normal": "Normal",
143   "notification.type.warning": "Warning",
144   "notification.type.critical": "Critical",
145   "notification.type.unknown": "Unknown",
146   "adminMonitoringPage.iotDevice": "IoT Device",
147   "adminMonitoringPage.notificationType": "Type",
148   "adminMonitoringPage.message": "Message",
149   "adminMonitoringPage.timestamp": "Timestamp",
150   "adminAccountManagementPage.createUser": "Create User",
151   "adminAccountManagementPage.password": "Password",
152   "adminAccountManagementPage.phone": "Phone",
153   "adminCreateUserPage.title": "Create User",
154   "adminCreateUserPage.createUser": "Create User",
155   "userAccountPage.saveChanges": "Save Changes",
156   "userAccountPage.cancel": "Cancel",
157   "userAccountPage.editAccount": "Edit Account",
158   "adminMonitoringPage.date": "Date",
159   "adminMonitoringPage.time": "Time",
160   "adminMonitoringPage.title": "IoT Notifications",
161   "userConsumptionHistoryPage.filterMenu": "Filters",
162   "userConsumptionHistoryPage.dateFrom": "Date From",
163   "userConsumptionHistoryPage.dateTo": "Date To",
164   "userConsumptionHistoryPage.amountFrom": "Amount From",
165   "userConsumptionHistoryPage.amountTo": "Amount To",
166   "userConsumptionHistoryPage.allResourceTypes": "All",
167   "userConsumptionHistoryPage.costFrom": "Cost From",
168   "userConsumptionHistoryPage.costTo": "Cost To",
169   "userConsumptionHistoryPage.dateFromPlaceholder": "mm/dd/yyyy",
170   "userConsumptionHistoryPage.dateToPlaceholder": "mm/dd/yyyy",
171   "adminHeader.backupManagement": "Backup Management",
172   "adminBackupManagementPage.title": "Backup Management",
173   "adminBackupManagementPage.createBackup": "Create Backup",
174   "adminIoTDeviceManagementPage.createdAt": "Created",
175   "adminIoTDeviceManagementPage.updatedAt": "Updated"
176 }


Б.16 Програмний код файлу ua.json


1 {
2   "app.title": "Ecomechan",
3   "app.home": "Home",
4   "app.about": "About",
5   "app.services": "Services",
6   "app.contacts": "Contacts",
7   "app.login": "Login",
8   "app.register": "Register",
9   "app.description": "Smart distribution of electricity, gas, and water resources.",
10   "footer.links": "Links",
11   "footer.about": "About Us",
12   "footer.contacts": "Contacts",
13   "footer.privacyPolicy": "Privacy Policy",
14   "footer.termsOfUse": "Terms of Use",
15   "footer.address": "Address: 14 Nauki Ave, Kharkiv, Kharkiv Oblast, 61166",
16   "footer.phone": "Phone: {phoneNumber}",
17   "footer.email": "Email: {email}",
18   "footer.copyright": "{copyright} 2023 Ecomechan. All rights reserved.",
19   "home.welcome": "Welcome to Ecomechan",
20   "home.description": "Smart distribution of electricity, gas, and water resources.",
21   "about.title": "About Us",
22   "about.description1": "EcoMeChan is an innovative software system designed for efficient management and optimization of utility resource consumption, such as water, electricity, and gas. Our mission is to promote sustainable development and reduce the negative impact on the environment through smart resource allocation.",
23   "about.description2": "We strive to help cities, businesses, and individual users reduce utility costs, increase resource efficiency, and ensure reliable supply. Utilizing advanced technologies and intelligent data analysis, EcoMeChan provides powerful tools for real-time monitoring, control, and optimization of resource consumption.",
24   "about.description3": "Our team consists of experienced professionals in the field of software development, energy, and resource management. We are dedicated to creating environmentally responsible solutions that help our clients achieve their goals in sustainable development and resource efficiency.",
25   "services.title": "Our Services",
26   "services.service1": "Service 1",
27   "services.service2": "Service 2",
28   "services.service3": "Service 3",
29   "contacts.title": "Contacts",
30   "contacts.address": "Address: 14 Nauki Ave, Kharkiv, Kharkiv Oblast, 61166",
31   "contacts.phone": "Phone: {phoneNumber}",
32   "contacts.email": "Email: {email}",
33   "login.title": "Login",
34   "login.email": "Email",
35   "login.password": "Password",
36   "login.submit": "Login",
37   "login.invalidCredentials": "Invalid email or password",
38   "registration.title": "Registration",
39   "registration.email": "Email",
40   "registration.password": "Password",
41   "registration.submit": "Register",
42   "registration.invalidCredentials": "Invalid email or password",
43   "adminFooter.title": "Admin Dashboard",
44   "adminFooter.copyright": "{copyright} 2023 Admin Dashboard. All rights reserved.",
45   "adminHeader.title": "Admin Dashboard",
46   "adminHeader.home": "Home",
47   "managerFooter.title": "Manager Dashboard",
48   "managerFooter.copyright": "{copyright} 2023 Manager Dashboard. All rights reserved.",
49   "managerHeader.title": "Manager Dashboard",
50   "managerHeader.home": "Home",
51   "userFooter.title": "User Dashboard",
52   "userFooter.copyright": "{copyright} 2023 User Dashboard. All rights reserved.",
53   "userHeader.title": "User Dashboard",
54   "userHeader.home": "Home",
55   "userHeader.personalAccount": "Personal Account",
56   "userHeader.consumptionHistory": "Consumption History",
57   "userHeader.iotDevices": "IoT Devices",
58   "userHeader.explore": "Explore",
59   "managerHeader.userProfile": "User Profile",
60   "managerHeader.consumptionHistory": "Consumption History",
61   "managerHeader.iotEvents": "IoT Events",
62   "adminHeader.accountManagement": "Account Management",
63   "adminHeader.iotDeviceManagement": "IoT Device Management",
64   "adminHeader.monitoring": "Monitoring",
65   "adminAccountPage.title": "Admin Account",
66   "adminAccountPage.login": "Login",
67   "adminAccountPage.email": "Email:",
68   "adminAccountPage.firstName": "First Name:",
69   "adminAccountPage.lastName": "Last Name:",
70   "adminAccountPage.middleName": "Middle Name:",
71   "adminAccountPage.phoneNumber": "Phone Number:",
72   "adminHomePage.welcome": "Welcome, Admin!",
73   "managerAccountPage.title": "Manager Account",
74   "managerAccountPage.login": "Login",
75   "managerAccountPage.email": "Email:",
76   "managerAccountPage.firstName": "First Name:",
77   "managerAccountPage.lastName": "Last Name:",
78   "managerAccountPage.middleName": "Middle Name:",
79   "managerAccountPage.phoneNumber": "Phone Number:",
80   "managerHomePage.welcome": "Welcome, Manager!",
81   "userAccountPage.title": "User Account",
82   "userAccountPage.login": "Login",
83   "userAccountPage.email": "Email:",
84   "userAccountPage.firstName": "First Name:",
85   "userAccountPage.lastName": "Last Name:",
86   "userAccountPage.middleName": "Middle Name:",
87   "userAccountPage.phoneNumber": "Phone Number:",
88   "userHomePage.welcome": "Welcome, User!",
89   "accountPage.logout": "Logout",
90   "userPersonalAccountPage.title": "Personal Account",
91   "userConsumptionHistoryPage.title": "Consumption History",
92   "userIoTDevicesPage.title": "IoT Devices",
93   "userExplorePage.title": "Explore",
94   "managerUserProfilePage.title": "User Profile",
95   "managerConsumptionHistoryPage.title": "Consumption History",
96   "managerIoTEventsPage.title": "IoT Events",
97   "adminAccountManagementPage.title": "Account Management",
98   "adminIoTDeviceManagementPage.title": "IoT Device Management",
99   "unit.water": "liters",
100   "unit.gas": "mВі",
101   "unit.electricity": "kWh",
102   "currency.usd": "USD",
103   "currency.eur": "EUR",
104   "currency.uah": "UAH",
105   "resourceType.water": "Water",
106   "resourceType.gas": "Gas",
107   "resourceType.electricity": "Electricity",
108   "userConsumptionHistoryPage.date": "Date",
109   "userConsumptionHistoryPage.resourceType": "Resource Type",
110   "userConsumptionHistoryPage.amount": "Amount",
111   "userConsumptionHistoryPage.cost": "Cost",
112   "userConsumptionHistoryPage.time": "Time",
113   "device.status.active": "Active",
114   "device.status.inactive": "Inactive",
115   "device.status.unknown": "Unknown",
116   "device.type.waterSensor": "Water Sensor",
117   "device.type.gasSensor": "Gas Sensor",
118   "device.type.electricitySensor": "Electricity Sensor",
119   "device.type.unknown": "Unknown",
120   "userIoTDevicesPage.deviceType": "Type: {deviceType}",
121   "userIoTDevicesPage.deviceStatus": "Status: {deviceStatus}",
122   "adminAccountManagementPage.login": "Login",
123   "adminAccountManagementPage.firstName": "First Name",
124   "adminAccountManagementPage.lastName": "Last Name",
125   "adminAccountManagementPage.middleName": "Middle Name",
126   "adminAccountManagementPage.email": "Email",
127   "adminAccountManagementPage.role": "Role",
128   "adminAccountManagementPage.actions": "Actions",
129   "adminAccountManagementPage.edit": "Edit",
130   "adminAccountManagementPage.delete": "Delete",
131   "role.user": "User",
132   "role.admin": "Admin",
133   "role.municipalResourceManager": "Municipal Resource Manager",
134   "role.unknown": "Unknown",
135   "adminIoTDeviceManagementPage.name": "Name",
136   "adminIoTDeviceManagementPage.type": "Type",
137   "adminIoTDeviceManagementPage.status": "Status",
138   "adminIoTDeviceManagementPage.edit": "Edit",
139   "adminIoTDeviceManagementPage.delete": "Delete",
140   "adminIoTDeviceManagementPage.save": "Save",
141   "adminIoTDeviceManagementPage.cancel": "Cancel",
142   "notification.type.normal": "Normal",
143   "notification.type.warning": "Warning",
144   "notification.type.critical": "Critical",
145   "notification.type.unknown": "Unknown",
146   "adminMonitoringPage.iotDevice": "IoT Device",
147   "adminMonitoringPage.notificationType": "Type",
148   "adminMonitoringPage.message": "Message",
149   "adminMonitoringPage.timestamp": "Timestamp",
150   "adminAccountManagementPage.createUser": "Create User",
151   "adminAccountManagementPage.password": "Password",
152   "adminAccountManagementPage.phone": "Phone",
153   "adminCreateUserPage.title": "Create User",
154   "adminCreateUserPage.createUser": "Create User",
155   "userAccountPage.saveChanges": "Save Changes",
156   "userAccountPage.cancel": "Cancel",
157   "userAccountPage.editAccount": "Edit Account",
158   "adminMonitoringPage.date": "Date",
159   "adminMonitoringPage.time": "Time",
160   "adminMonitoringPage.title": "IoT Notifications",
161   "userConsumptionHistoryPage.filterMenu": "Filters",
162   "userConsumptionHistoryPage.dateFrom": "Date From",
163   "userConsumptionHistoryPage.dateTo": "Date To",
164   "userConsumptionHistoryPage.amountFrom": "Amount From",
165   "userConsumptionHistoryPage.amountTo": "Amount To",
166   "userConsumptionHistoryPage.allResourceTypes": "All",
167   "userConsumptionHistoryPage.costFrom": "Cost From",
168   "userConsumptionHistoryPage.costTo": "Cost To",
169   "userConsumptionHistoryPage.dateFromPlaceholder": "mm/dd/yyyy",
170   "userConsumptionHistoryPage.dateToPlaceholder": "mm/dd/yyyy",
171   "adminHeader.backupManagement": "Backup Management",
172   "adminBackupManagementPage.title": "Backup Management",
173   "adminBackupManagementPage.createBackup": "Create Backup",
174   "adminIoTDeviceManagementPage.createdAt": "Created",
175   "adminIoTDeviceManagementPage.updatedAt": "Updated"
176 }


Б.17 Програмний код файлу DateUtils.js


1 // src/utils/DateUtils.js
2 import { format, parseISO } from 'date-fns';
3 
4 export const formatDate = (dateString, locale) => {
5     const date = parseISO(dateString);
6     const formatPattern = locale === 'uk' ? 'dd/MM/yyyy' : 'MM/dd/yyyy';
7     return format(date, formatPattern);
8 };
9 
10 export const formatTime = (dateString, locale) => {
11     const date = parseISO(dateString);
12     const formatPattern = locale === 'uk' ? 'HH:mm:ss' : 'h:mm:ss a';
13     return format(date, formatPattern);
14 };


Б.18 Програмний код файлу UserConsumptionHistoryPage.js


1 // src/pages/user/UserConsumptionHistoryPage.js
2 import React, { useContext, useEffect, useMemo, useState } from 'react';
3 import { FormattedMessage, useIntl } from 'react-intl';
4 import { format, parseISO } from 'date-fns';
5 import { AuthContext } from '../../contexts/AuthContext';
6 import { getUserConsumptionHistory } from '../../services/ConsumptionService';
7 import ResourceType from '../../enums/ResourceType';
8 import { formatDate, formatTime } from '../../utils/DateUtils';
9 
10 
11 const UserConsumptionHistoryPage = () => {
12     const { user } = useContext(AuthContext);
13     const [consumptionHistory, setConsumptionHistory] = useState([]);
14     const [sortColumn, setSortColumn] = useState(null);
15     const [sortOrder, setSortOrder] = useState('asc');
16     const [filters, setFilters] = useState({
17         dateFrom: '',
18         dateTo: '',
19         amountFrom: '',
20         amountTo: '',
21         resourceType: '',
22         costFrom: '',
23         costTo: '',
24     });
25     const [errors, setErrors] = useState({
26         dateFrom: '',
27         dateTo: '',
28         amountFrom: '',
29         amountTo: '',
30         costFrom: '',
31         costTo: '',
32     });
33     const [openFilterMenu, setOpenFilterMenu] = useState(false);
34     const intl = useIntl();
35     const locale = intl.locale;
36 
37     useEffect(() => {
38         const fetchUserConsumptionHistory = async () => {
39             try {
40                 const history = await getUserConsumptionHistory(user.id);
41                 setConsumptionHistory(history);
42             } catch (error) {
43                 console.error('Error fetching user consumption history:', error);
44             }
45         };
46 
47         if (user) {
48             fetchUserConsumptionHistory();
49         }
50     }, [user]);
51 
52     const formatAmount = (amount) => {
53         return Number(amount).toFixed(2);
54     };
55 
56     const formatCost = (cost) => {
57         return Number(cost).toFixed(2);
58     };
59 
60     const getLocalizedResourceType = (resourceType) => {
61         switch (resourceType) {
62             case ResourceType.Water:
63                 return intl.formatMessage({ id: 'resourceType.water', defaultMessage: 'Water' });
64             case ResourceType.Gas:
65                 return intl.formatMessage({ id: 'resourceType.gas', defaultMessage: 'Gas' });
66             case ResourceType.Electricity:
67                 return intl.formatMessage({ id: 'resourceType.electricity', defaultMessage: 'Electricity' });
68             default:
69                 return '';
70         }
71     };
72 
73     const convertUnit = (value, fromUnit, toUnit) => {
74         if (fromUnit === toUnit) {
75             return value;
76         }
77 
78         switch (fromUnit) {
79             // Water conversions
80             case 'mВі':
81                 if (toUnit === 'l') {
82                     return value * 1000;
83                 } else if (toUnit === 'gal') {
84                     return value * 264.172;
85                 } else if (toUnit === 'ftВі') {
86                     return value * 35.3147;
87                 }
88                 break;
89             case 'l':
90                 if (toUnit === 'mВі') {
91                     return value / 1000;
92                 } else if (toUnit === 'gal') {
93                     return value * 0.264172;
94                 }
95                 break;
96             case 'gal':
97                 if (toUnit === 'mВі') {
98                     return value / 264.172;
99                 } else if (toUnit === 'l') {
100                     return value / 0.264172;
101                 }
102                 break;
103 
104             // Gas conversions
105             case 'ftВі':
106                 if (toUnit === 'mВі') {
107                     return value / 35.3147;
108                 }
109                 break;
110 
111             // Electricity conversions
112             case 'kWh':
113                 if (toUnit === 'MWh') {
114                     return value / 1000;
115                 } else if (toUnit === 'J') {
116                     return value * 3.6e6;
117                 }
118                 break;
119             case 'MWh':
120                 if (toUnit === 'kWh') {
121                     return value * 1000;
122                 } else if (toUnit === 'J') {
123                     return value * 3.6e9;
124                 }
125                 break;
126             case 'J':
127                 if (toUnit === 'kWh') {
128                     return value / 3.6e6;
129                 } else if (toUnit === 'MWh') {
130                     return value / 3.6e9;
131                 }
132                 break;
133             default:
134                 return value;
135         }
136     };
137 
139     const getLocalizedUnit = (resourceType) => {
140         switch (resourceType) {
141             case ResourceType.Water:
142                 return locale === 'uk' ? 'mВі' : 'gal';
143             case ResourceType.Gas:
144                 return locale === 'uk' ? 'mВі' : 'ftВі';
145             case ResourceType.Electricity:
146                 return 'kWh';
147             default:
148                 return '';
149         }
150     };
151 
153     const convertAmount = (amount, resourceType, unitFrom) => {
154         const localizedUnit = getLocalizedUnit(resourceType);
155         return convertUnit(amount, unitFrom, localizedUnit);
156     };
157 
158     const exchangeRates = JSON.parse(localStorage.getItem('exchangeRates'));
159 
160 
161     const convertCurrency = (cost, fromCurrency, toCurrency) => {
162         if (fromCurrency === toCurrency) {
163             return cost;
164         }
165 
166         const exchangeRate = exchangeRates[`${fromCurrency}_${toCurrency}`];
167         return cost * exchangeRate;
168     };
169 
170     const getLocalizedCurrency = (currencyCode) => {
171         switch (currencyCode) {
172             case 'USD':
173                 return intl.formatMessage({ id: 'currency.usd', defaultMessage: 'USD' });
174             case 'EUR':
175                 return intl.formatMessage({ id: 'currency.eur', defaultMessage: 'EUR' });
176             case 'UAH':
177                 return intl.formatMessage({ id: 'currency.uah', defaultMessage: 'UAH' });
178             default:
179                 return currencyCode;
180         }
181     };
182 
183     const handleSort = (column) => {
184         if (column === sortColumn) {
185             setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
186         } else {
187             setSortColumn(column);
188             setSortOrder('asc');
189         }
190     };
191 
192     const handleFilterChange = (e) => {
193         const { name, value } = e.target;
194         setFilters((prevFilters) => ({ ...prevFilters, [name]: value }));
195     };
196 
197     const toggleFilterMenu = () => {
198         setOpenFilterMenu(!openFilterMenu);
199     };
200 
201     const validateFilters = () => {
202         const newErrors = {
203             dateFrom: '',
204             dateTo: '',
205             amountFrom: '',
206             amountTo: '',
207             costFrom: '',
208             costTo: '',
209         };
210 
211         if (filters.dateFrom && filters.dateTo) {
212             const dateFrom = new Date(filters.dateFrom);
213             const dateTo = new Date(filters.dateTo);
214             dateTo.setDate(dateTo.getDate() + 1); // Р”РѕРґР°С”РјРѕ РѕРґРёРЅ РґРµРЅСЊ РґРѕ РґР°С‚Рё "РґРѕ"
215 
216             if (dateFrom > dateTo) {
217                 newErrors.dateFrom = 'Date From cannot be greater than Date To';
218                 newErrors.dateTo = 'Date To cannot be less than Date From';
219             }
220         }
221 
222         if (filters.amountFrom && filters.amountTo && Number(filters.amountFrom) > Number(filters.amountTo)) {
223             newErrors.amountFrom = 'Amount From cannot be greater than Amount To';
224             newErrors.amountTo = 'Amount To cannot be less than Amount From';
225         }
226 
227         if (filters.costFrom && filters.costTo && Number(filters.costFrom) > Number(filters.costTo)) {
228             newErrors.costFrom = 'Cost From cannot be greater than Cost To';
229             newErrors.costTo = 'Cost To cannot be less than Cost From';
230         }
231 
232         setErrors(newErrors);
233 
234         return Object.values(newErrors).every((error) => error === '');
235     };
236 
237     const filteredConsumptionHistory = useMemo(() => {
238         if (!validateFilters()) {
239             return [];
240         }
241 
242         return consumptionHistory.filter((item) => {
243             const date = new Date(item.date);
244             const amount = Number(item.consumedAmount);
245             const cost = Number(item.consumedCost);
246             const dateFrom = filters.dateFrom ? new Date(filters.dateFrom) : null;
247             const dateTo = filters.dateTo ? new Date(filters.dateTo) : null;
248 
249             if (dateFrom && date < dateFrom) {
250                 return false;
251             }
252             if (dateTo) {
253                 dateTo.setDate(dateTo.getDate() + 1); // Р”РѕРґР°С”РјРѕ РѕРґРёРЅ РґРµРЅСЊ РґРѕ РґР°С‚Рё "РґРѕ"
254                 if (date > dateTo) {
255                     return false;
256                 }
257             }
258             if (filters.amountFrom && amount < Number(filters.amountFrom)) {
259                 return false;
260             }
261             if (filters.amountTo && amount > Number(filters.amountTo)) {
262                 return false;
263             }
264             if (filters.resourceType && item.resourceType !== Number(filters.resourceType)) {
265                 return false;
266             }
267             if (filters.costFrom && cost < Number(filters.costFrom)) {
268                 return false;
269             }
270             if (filters.costTo && cost > Number(filters.costTo)) {
271                 return false;
272             }
273 
274             return true;
275         });
276     }, [consumptionHistory, filters]);
277 
278     const sortedConsumptionHistory = useMemo(() => {
279         if (!sortColumn) return filteredConsumptionHistory;
280 
281         return [...filteredConsumptionHistory].sort((a, b) => {
282             if (a[sortColumn] < b[sortColumn]) return sortOrder === 'asc' ? -1 : 1;
283             if (a[sortColumn] > b[sortColumn]) return sortOrder === 'asc' ? 1 : -1;
284             return 0;
285         });
286     }, [filteredConsumptionHistory, sortColumn, sortOrder]);
287 
288     return (
289         <main className="main py-5">
290             <div className="container">
291                 <h2>
292                     <FormattedMessage
293                         id="userConsumptionHistoryPage.title"
294                         defaultMessage="Consumption History"
295                     />
296                 </h2>
297 
298                 {/* Р’РёРїР°РґР°СЋС‡Рµ РјРµРЅСЋ С„С–Р»СЊС‚СЂС–РІ */}
299                 <div className="dropdown mb-3">
300                     <button
301                         className="btn btn-secondary dropdown-toggle"
302                         type="button"
303                         onClick={toggleFilterMenu}
304                     >
305                         <FormattedMessage
306                             id="userConsumptionHistoryPage.filterMenu"
307                             defaultMessage="Filters"
308                         />
309                     </button>
310                     {openFilterMenu && (
311                         <div className="dropdown-menu show">
312                             <div className="px-3 py-2">
313                                 {/* Р¤С–Р»СЊС‚СЂ Р·Р° РґР°С‚РѕСЋ */}
314                                 <div className="row mb-3">
315                                     <div className="col-md-6">
316                                         <label htmlFor="dateFrom">
317                                             <FormattedMessage
318                                                 id="userConsumptionHistoryPage.dateFrom"
319                                                 defaultMessage="Date From"
320                                             />
321                                         </label>
322                                         <input
323                                             type="text"
324                                             id="dateFrom"
325                                             name="dateFrom"
326                                             className="form-control"
327                                             value={filters.dateFrom}
328                                             onChange={handleFilterChange}
329                                             placeholder={intl.formatMessage({
330                                                 id: 'userConsumptionHistoryPage.dateFromPlaceholder',
331                                             })}
332                                             onFocus={(e) => (e.target.type = 'date')}
333                                             onBlur={(e) => (e.target.type = 'text')}
334                                         />
335                                     </div>
336                                     <div className="col-md-6">
337                                         <label htmlFor="dateTo">
338                                             <FormattedMessage
339                                                 id="userConsumptionHistoryPage.dateTo"
340                                                 defaultMessage="Date To"
341                                             />
342                                         </label>
343                                         <input
344                                             type="text"
345                                             id="dateTo"
346                                             name="dateTo"
347                                             className="form-control"
348                                             value={filters.dateTo}
349                                             onChange={handleFilterChange}
350                                             placeholder={intl.formatMessage({
351                                                 id: 'userConsumptionHistoryPage.dateToPlaceholder',
352                                             })}
353                                             onFocus={(e) => (e.target.type = 'date')}
354                                             onBlur={(e) => (e.target.type = 'text')}
355                                         />
356                                     </div>
357                                 </div>
358 
359                                 {/* Р¤С–Р»СЊС‚СЂ Р·Р° РєС–Р»СЊРєС–СЃС‚СЋ */}
360                                 <div className="mb-3">
361                                     <label htmlFor="amountFrom">
362                                         <FormattedMessage
363                                             id="userConsumptionHistoryPage.amountFrom"
364                                             defaultMessage="Amount From"
365                                         />
366                                     </label>
367                                     <input
368                                         type="number"
369                                         id="amountFrom"
370                                         name="amountFrom"
371                                         className={`form-control ${errors.amountFrom ? 'is-invalid' : ''}`}
372                                         value={filters.amountFrom}
373                                         onChange={handleFilterChange}
374                                     />
375                                     {errors.amountFrom && (
376                                         <div className="invalid-feedback">{errors.amountFrom}</div>
377                                     )}
378                                 </div>
379                                 <div className="mb-3">
380                                     <label htmlFor="amountTo">
381                                         <FormattedMessage
382                                             id="userConsumptionHistoryPage.amountTo"
383                                             defaultMessage="Amount To"
384                                         />
385                                     </label>
386                                     <input
387                                         type="number"
388                                         id="amountTo"
389                                         name="amountTo"
390                                         className={`form-control ${errors.amountTo ? 'is-invalid' : ''}`}
391                                         value={filters.amountTo}
392                                         onChange={handleFilterChange}
393                                     />
394                                     {errors.amountTo && (
395                                         <div className="invalid-feedback">{errors.amountTo}</div>
396                                     )}
397                                 </div>
398 
399                                 {/* Р¤С–Р»СЊС‚СЂ Р·Р° С‚РёРїРѕРј СЂРµСЃСѓСЂСЃСѓ */}
400                                 <div className="mb-3">
401                                     <label htmlFor="resourceType">
402                                         <FormattedMessage
403                                             id="userConsumptionHistoryPage.resourceType"
404                                             defaultMessage="Resource Type"
405                                         />
406                                     </label>
407                                     <select
408                                         id="resourceType"
409                                         name="resourceType"
410                                         className="form-control"
411                                         value={filters.resourceType}
412                                         onChange={handleFilterChange}
413                                     >
414                                         <option value="">
415                                             <FormattedMessage
416                                                 id="userConsumptionHistoryPage.allResourceTypes"
417                                                 defaultMessage="All"
418                                             />
419                                         </option>
420                                         <option value={ResourceType.Water}>
421                                             {getLocalizedResourceType(ResourceType.Water)}
422                                         </option>
423                                         <option value={ResourceType.Gas}>
424                                             {getLocalizedResourceType(ResourceType.Gas)}
425                                         </option>
426                                         <option value={ResourceType.Electricity}>
427                                             {getLocalizedResourceType(ResourceType.Electricity)}
428                                         </option>
429                                     </select>
430                                 </div>
431 
432                                 {/* Р¤С–Р»СЊС‚СЂ Р·Р° РІР°СЂС‚С–СЃС‚СЋ */}
433                                 <div className="mb-3">
434                                     <label htmlFor="costFrom">
435                                         <FormattedMessage
436                                             id="userConsumptionHistoryPage.costFrom"
437                                             defaultMessage="Cost From"
438                                         />
439                                     </label>
440                                     <input
441                                         type="number"
442                                         id="costFrom"
443                                         name="costFrom"
444                                         className={`form-control ${errors.costFrom ? 'is-invalid' : ''}`}
445                                         value={filters.costFrom}
446                                         onChange={handleFilterChange}
447                                     />
448                                     {errors.costFrom && (
449                                         <div className="invalid-feedback">{errors.costFrom}</div>
450                                     )}
451                                 </div>
452                                 <div>
453                                     <label htmlFor="costTo">
454                                         <FormattedMessage
455                                             id="userConsumptionHistoryPage.costTo"
456                                             defaultMessage="Cost To"
457                                         />
458                                     </label>
459                                     <input
460                                         type="number"
461                                         id="costTo"
462                                         name="costTo"
463                                         className={`form-control ${errors.costTo ? 'is-invalid' : ''}`}
464                                         value={filters.costTo}
465                                         onChange={handleFilterChange}
466                                     />
467                                     {errors.costTo && (
468                                         <div className="invalid-feedback">{errors.costTo}</div>
469                                     )}
470                                 </div>
471                             </div>
472                         </div>
473                     )}
474                 </div>
475 
476                 <table className="table table-sort">
477                     <thead>
478                     <tr>
479                         <th onClick={() => handleSort('date')}>
480                             <FormattedMessage
481                                 id="userConsumptionHistoryPage.date"
482                                 defaultMessage="Date"
483                             />
484                             {sortColumn === 'date' && (
485                                 <i className={`fas ${sortOrder === 'asc' ? 'fa-sort-up' : 'fa-sort-down'}`}></i>
486                             )}
487                         </th>
488                         <th onClick={() => handleSort('date')}>
489                             <FormattedMessage
490                                 id="userConsumptionHistoryPage.time"
491                                 defaultMessage="Time"
492                             />
493                             {sortColumn === 'date' && (
494                                 <i className={`fas ${sortOrder === 'asc' ? 'fa-sort-up' : 'fa-sort-down'}`}></i>
495                             )}
496                         </th>
497                         <th onClick={() => handleSort('resourceType')}>
498                             <FormattedMessage
499                                 id="userConsumptionHistoryPage.resourceType"
500                                 defaultMessage="Resource Type"
501                             />
502                             {sortColumn === 'resourceType' && (
503                                 <i className={`fas ${sortOrder === 'asc' ? 'fa-sort-up' : 'fa-sort-down'}`}></i>
504                             )}
505                         </th>
506                         <th onClick={() => handleSort('consumedAmount')}>
507                             <FormattedMessage
508                                 id="userConsumptionHistoryPage.amount"
509                                 defaultMessage="Amount"
510                             />
511                             {sortColumn === 'consumedAmount' && (
512                                 <i className={`fas ${sortOrder === 'asc' ? 'fa-sort-up' : 'fa-sort-down'}`}></i>
513                             )}
514                         </th>
515                         <th onClick={() => handleSort('consumedCost')}>
516                             <FormattedMessage
517                                 id="userConsumptionHistoryPage.cost"
518                                 defaultMessage="Cost"
519                             />
520                             {sortColumn === 'consumedCost' && (
521                                 <i className={`fas ${sortOrder === 'asc' ? 'fa-sort-up' : 'fa-sort-down'}`}></i>
522                             )}
523                         </th>
524                     </tr>
525                     </thead>
526                     <tbody>
527                     {sortedConsumptionHistory.map((item) => {
528                         const localizedCurrency = locale === 'uk' ? 'UAH' : 'USD';
529                         const convertedCost = convertCurrency(item.consumedCost, item.currencyCode, localizedCurrency);
530 
531                         const localizedUnit = getLocalizedUnit(item.resourceType);
532                         const convertedAmount = convertAmount(
533                             item.consumedAmount,
534                             item.resourceType,
535                             item.unit
536                         );
537 
538                         return (
539                             <tr key={item.id}>
540                                 <td>{formatDate(item.date, locale)}</td>
541                                 <td>{formatTime(item.date, locale)}</td>
542                                 <td>{getLocalizedResourceType(item.resourceType)}</td>
543                                 <td>
544                                     {formatAmount(convertedAmount)} {localizedUnit}
545                                 </td>
546                                 <td>
547                                     {formatCost(convertedCost)} {getLocalizedCurrency(localizedCurrency)}
548                                 </td>
549                             </tr>
550                         );
551                     })}
552                     </tbody>
553                 </table>
554             </div>
555         </main>
556     );
557 };
558 
559 export default UserConsumptionHistoryPage;


Б.19 Програмний код файлу LanguageContext.js


1 // src/contexts/LanguageContext.js
2 import React, { createContext, useState } from 'react';
3 
4 export const LanguageContext = createContext();
5 
6 export const LanguageProvider = ({ children }) => {
7     const [language, setLanguage] = useState(localStorage.getItem('language') || navigator.language.split(/[-_]/)[0]);
8 
9     const changeLanguage = (newLanguage) => {
10         setLanguage(newLanguage);
11         localStorage.setItem('language', newLanguage);
12     };
13 
14     return (
15         <LanguageContext.Provider value={{ language, changeLanguage }}>
16             {children}
17         </LanguageContext.Provider>
18     );
19 };


Б.20 Програмний код файлу AuthContext.js


1 // src/contexts/AuthContext.js
2 import React, { createContext, useState, useEffect } from 'react';
3 import { logout as logoutService } from '../services/AuthService';
4 
5 export const AuthContext = createContext();
6 
7 export const AuthProvider = ({ children }) => {
8     const [user, setUser] = useState(null);
9 
10     useEffect(() => {
11         const storedUser = localStorage.getItem('user');
12         if (storedUser) {
13             setUser(JSON.parse(storedUser));
14         }
15     }, []);
16 
17     const login = (userData) => {
18         setUser(userData);
19         localStorage.setItem('user', JSON.stringify(userData));
20     };
21 
22     const logout = async () => {
23         try {
24             await logoutService();
25             localStorage.removeItem('user');
26             setUser(null);
27         } catch (error) {
28             console.error('Logout failed:', error);
29         }
30     };
31 
32     return (
33         <AuthContext.Provider value={{ user, setUser, login, logout }}>
34             {children}
35         </AuthContext.Provider>
36     );
37 };


Б.21 Програмний код файлу App.xaml.cs


1 using EcoMeChan_Mobile.Enums;
2 using EcoMeChan_Mobile.Resources.Languages;
3 using EcoMeChan_Mobile.Services;
4 using System.Globalization;
5 using Newtonsoft.Json;
6 
7 namespace EcoMeChan_Mobile;
8 
9 public partial class App : Application
10 {
11     public App()
12     {
13         InitializeComponent();
14 
15         var culture = new CultureInfo("en");
16         AppResources.Culture = culture;
17 
18         var authService = new AuthService();
19         var savedUser = authService.GetUser();
20 
21         if (savedUser != null)
22         {
23             if (savedUser.Role == Role.User)
24             {
25                 MainPage = new AppShell();
26                 Shell.Current.GoToAsync("//UserTab/UserAccountPage");
27             }
28             else if (savedUser.Role == Role.Admin)
29             {
30                 MainPage = new AppShell();
31                 Shell.Current.GoToAsync("//AdminTab/AdminAccountPage");
32             }
33         }
34         else
35         {
36             MainPage = new AppShell();
37         }
38 
39         FetchAndSaveExchangeRates();
40     }
41 
42     private async void FetchAndSaveExchangeRates()
43     {
44         var currencyService = new CurrencyService();
45         var exchangeRates = await currencyService.FetchExchangeRates();
46 
47         if (exchangeRates != null)
48         {
49             var exchangeRatesJson = JsonConvert.SerializeObject(exchangeRates);
50             Preferences.Set("ExchangeRates", exchangeRatesJson);
51         }
52     }
53 }


Б.22 Програмний код файлу AuthService.cs


1 using System.Net.Http;
2 using System.Text;
3 using System.Threading.Tasks;
4 using EcoMeChan_Mobile.Models;
5 using Newtonsoft.Json;
6 
7 namespace EcoMeChan_Mobile.Services
8 {
9     public class AuthService
10     {
11         private readonly HttpClient _httpClient;
12         private readonly string _apiBaseUrl;
13         private const string UserKey = "user_key";
14 
15         public AuthService()
16         {
17             _httpClient = new HttpClient();
18             _apiBaseUrl = "https://525f-149-88-110-59.ngrok-free.app"; // Захардкоджене значення URL-адреси API
19         }
20 
21         public async Task<User> LoginAsync(LoginCredentials credentials)
22         {
23             var json = JsonConvert.SerializeObject(credentials);
24             var content = new StringContent(json, Encoding.UTF8, "application/json");
25 
26             var response = await _httpClient.PostAsync($"{_apiBaseUrl}/api/User/authenticate", content);
27             var responseContent = await response.Content.ReadAsStringAsync();
28 
29             if (response.IsSuccessStatusCode)
30             {
31                 var user = JsonConvert.DeserializeObject<User>(responseContent);
32                 SaveUser(user);
33                 return user;
34             }
35             else
36             {
37                 // Обробка помилки авторизації
38                 return null;
39             }
40         }
41 
42         public async Task<User> RegisterAsync(HttpContent content)
43         {
44             var response = await _httpClient.PostAsync($"{_apiBaseUrl}/api/User", content);
45             var responseContent = await response.Content.ReadAsStringAsync();
46 
47             if (response.IsSuccessStatusCode)
48             {
49                 var registeredUser = JsonConvert.DeserializeObject<User>(responseContent);
50                 return registeredUser;
51             }
52             else
53             {
54                 // Обробка помилки реєстрації
55                 return null;
56             }
57         }
58 
59         public async Task<bool> UpdateUserAsync(int userId, User userData)
60         {
61             var json = JsonConvert.SerializeObject(userData);
62             var content = new StringContent(json, Encoding.UTF8, "application/json");
63 
64             var response = await _httpClient.PutAsync($"{_apiBaseUrl}/api/User/{userId}", content);
65 
66             return response.IsSuccessStatusCode;
67         }
68 
69         public async Task LogoutAsync()
70         {
71             var response = await _httpClient.PostAsync($"{_apiBaseUrl}/api/User/logout", null);
72             if (response.IsSuccessStatusCode)
73             {
74                 RemoveUser();
75             }
76         }
77 
78         public void SaveUser(User user)
79         {
80             string userJson = JsonConvert.SerializeObject(user);
81             Preferences.Set(UserKey, userJson);
82         }
83 
84         public User GetUser()
85         {
86             string userJson = Preferences.Get(UserKey, null);
87             if (!string.IsNullOrEmpty(userJson))
88             {
89                 return JsonConvert.DeserializeObject<User>(userJson);
90             }
91             return null;
92         }
93 
94         public void RemoveUser()
95         {
96             Preferences.Remove(UserKey);
97         }
98 
99         
100     }
101 }


Б.23 Програмний код файлу ConsumptionService.cs


1 using EcoMeChan_Mobile.Models;
2 using Newtonsoft.Json;
3 using System.Collections.Generic;
4 using System.Net.Http;
5 using System.Threading.Tasks;
6 
7 namespace EcoMeChan_Mobile.Services
8 {
9     public class ConsumptionService
10     {
11         private readonly HttpClient _httpClient;
12         private readonly string _apiBaseUrl;
13 
14         public ConsumptionService()
15         {
16             _httpClient = new HttpClient();
17             _apiBaseUrl = "https://525f-149-88-110-59.ngrok-free.app";
18         }
19 
20         public async Task<List<Consumption>> GetUserConsumptionHistory(int userId)
21         {
22             var response = await _httpClient.GetAsync($"{_apiBaseUrl}/api/Consumption/user/{userId}");
23             var responseContent = await response.Content.ReadAsStringAsync();
24 
25             if (response.IsSuccessStatusCode)
26             {
27                 var history = JsonConvert.DeserializeObject<List<Consumption>>(responseContent);
28                 return history;
29             }
30             else
31             {
32                 // Handle error
33                 return null;
34             }
35         }
36     }
37 }


Б.24 Програмний код файлу IoTDeviceService.cs


1 // Services/IoTDeviceService.cs
2 using System.Collections.Generic;
3 using System.Net.Http;
4 using System.Text;
5 using System.Threading.Tasks;
6 using EcoMeChan_Mobile.Models;
7 using Newtonsoft.Json;
8 
9 namespace EcoMeChan_Mobile.Services
10 {
11     public class IoTDeviceService
12     {
13         private readonly HttpClient _httpClient;
14         private readonly string _apiBaseUrl;
15 
16         public IoTDeviceService()
17         {
18             _httpClient = new HttpClient();
19             _apiBaseUrl = "https://525f-149-88-110-59.ngrok-free.app"; 
20         }
21 
22         public async Task<List<IoTDevice>> GetUserIoTDevices(int userId)
23         {
24             var response = await _httpClient.GetAsync($"{_apiBaseUrl}/api/IoTDevice/user/{userId}");
25             var responseContent = await response.Content.ReadAsStringAsync();
26 
27             if (response.IsSuccessStatusCode)
28             {
29                 var devices = JsonConvert.DeserializeObject<List<IoTDevice>>(responseContent);
30                 return devices;
31             }
32             else
33             {
34                 // Обробка помилки отримання даних
35                 return null;
36             }
37         }
38 
39         public async Task<List<IoTDevice>> GetAllIoTDevicesAsync()
40         {
41             var response = await _httpClient.GetAsync($"{_apiBaseUrl}/api/IoTDevice");
42             var responseContent = await response.Content.ReadAsStringAsync();
43 
44             if (response.IsSuccessStatusCode)
45             {
46                 var devices = JsonConvert.DeserializeObject<List<IoTDevice>>(responseContent);
47                 return devices;
48             }
49             else
50             {
51                 // Обробка помилки
52                 return null;
53             }
54         }
55 
56         public async Task<bool> UpdateIoTDeviceAsync(int deviceId, IoTDevice deviceData)
57         {
58             var json = JsonConvert.SerializeObject(deviceData);
59             var content = new StringContent(json, Encoding.UTF8, "application/json");
60 
61             var response = await _httpClient.PutAsync($"{_apiBaseUrl}/api/IoTDevice/{deviceId}", content);
62 
63             return response.IsSuccessStatusCode;
64         }
65 
66         public async Task<bool> DeleteIoTDeviceAsync(int deviceId)
67         {
68             var response = await _httpClient.DeleteAsync($"{_apiBaseUrl}/api/IoTDevice/{deviceId}");
69 
70             return response.IsSuccessStatusCode;
71         }
72     }
73 }


Б.25 Програмний код файлу ResourceTypeConverter.cs


1 using System;
2 using System.Globalization;
3 using EcoMeChan_Mobile.Enums;
4 using EcoMeChan_Mobile.Resources.Languages;
5 
6 namespace EcoMeChan_Mobile.Utils
7 {
8     public class ResourceTypeConverter : IValueConverter
9     {
10         public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
11         {
12             if (value is ResourceType resourceType)
13             {
14                 switch (resourceType)
15                 {
16                     case ResourceType.Water:
17                         return AppResources.ResourceTypeWater;
18                     case ResourceType.Gas:
19                         return AppResources.ResourceTypeGas;
20                     case ResourceType.Electricity:
21                         return AppResources.ResourceTypeElectricity;
22                     default:
23                         return string.Empty;
24                 }
25             }
26 
27             return string.Empty;
28         }
29 
30         public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
31         {
32             throw new NotImplementedException();
33         }
34     }
35 }
 
ДОДАТОК В
Перевірка на плагіат



